{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.18\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { _DYN_COMPLETE, _DYN_GET_CTX, _DYN_IS_ASYNC, _DYN_IS_CHILD_EVT, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_CTX, _DYN_TIME } from \"../__DynamicConstants\";\nimport { dateNow, isArray, isFunction, objDefineAccessors } from \"./HelperFuncs\";\nimport { STR_GET_PERF_MGR, STR_PERF_EVENT } from \"./InternalConstants\";\nvar strExecutionContextKey = \"ctx\";\nvar strParentContextKey = \"ParentContextKey\";\nvar strChildrenContextKey = \"ChildrenContextKey\";\nvar _defaultPerfManager = null;\n\nvar PerfEvent =\n/** @class */\nfunction () {\n  function PerfEvent(name, payloadDetails, isAsync) {\n    var _self = this;\n\n    var accessorDefined = false;\n    _self.start = dateNow();\n    _self[_DYN_NAME\n    /* @min:%2ename */\n    ] = name;\n    _self[_DYN_IS_ASYNC\n    /* @min:%2eisAsync */\n    ] = isAsync;\n\n    _self[_DYN_IS_CHILD_EVT\n    /* @min:%2eisChildEvt */\n    ] = function () {\n      return false;\n    };\n\n    if (isFunction(payloadDetails)) {\n      // Create an accessor to minimize the potential performance impact of executing the payloadDetails callback\n      var theDetails_1;\n      accessorDefined = objDefineAccessors(_self, \"payload\", function () {\n        // Delay the execution of the payloadDetails until needed\n        if (!theDetails_1 && isFunction(payloadDetails)) {\n          theDetails_1 = payloadDetails(); // clear it out now so the referenced objects can be garbage collected\n\n          payloadDetails = null;\n        }\n\n        return theDetails_1;\n      });\n    }\n\n    _self[_DYN_GET_CTX\n    /* @min:%2egetCtx */\n    ] = function (key) {\n      if (key) {\n        // The parent and child links are located directly on the object (for better viewing in the DebugPlugin)\n        if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {\n          return _self[key];\n        }\n\n        return (_self[strExecutionContextKey] || {})[key];\n      }\n\n      return null;\n    };\n\n    _self[_DYN_SET_CTX\n    /* @min:%2esetCtx */\n    ] = function (key, value) {\n      if (key) {\n        // Put the parent and child links directly on the object (for better viewing in the DebugPlugin)\n        if (key === PerfEvent[strParentContextKey]) {\n          // Simple assumption, if we are setting a parent then we must be a child\n          if (!_self[key]) {\n            _self[_DYN_IS_CHILD_EVT\n            /* @min:%2eisChildEvt */\n            ] = function () {\n              return true;\n            };\n          }\n\n          _self[key] = value;\n        } else if (key === PerfEvent[strChildrenContextKey]) {\n          _self[key] = value;\n        } else {\n          var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\n          ctx[key] = value;\n        }\n      }\n    };\n\n    _self[_DYN_COMPLETE\n    /* @min:%2ecomplete */\n    ] = function () {\n      var childTime = 0;\n\n      var childEvts = _self[_DYN_GET_CTX\n      /* @min:%2egetCtx */\n      ](PerfEvent[strChildrenContextKey]);\n\n      if (isArray(childEvts)) {\n        for (var lp = 0; lp < childEvts[_DYN_LENGTH\n        /* @min:%2elength */\n        ]; lp++) {\n          var childEvt = childEvts[lp];\n\n          if (childEvt) {\n            childTime += childEvt[_DYN_TIME\n            /* @min:%2etime */\n            ];\n          }\n        }\n      }\n\n      _self[_DYN_TIME\n      /* @min:%2etime */\n      ] = dateNow() - _self.start;\n      _self.exTime = _self[_DYN_TIME\n      /* @min:%2etime */\n      ] - childTime;\n\n      _self[_DYN_COMPLETE\n      /* @min:%2ecomplete */\n      ] = function () {};\n\n      if (!accessorDefined && isFunction(payloadDetails)) {\n        // If we couldn't define the property set during complete -- to minimize the perf impact until after the time\n        _self.payload = payloadDetails();\n      }\n    };\n  }\n\n  PerfEvent.ParentContextKey = \"parent\";\n  PerfEvent.ChildrenContextKey = \"childEvts\";\n  return PerfEvent;\n}();\n\nexport { PerfEvent };\n\nvar PerfManager =\n/** @class */\nfunction () {\n  function PerfManager(manager) {\n    /**\r\n     * General bucket used for execution context set and retrieved via setCtx() and getCtx.\r\n     * Defined as private so it can be visualized via the DebugPlugin\r\n     */\n    this.ctx = {};\n    dynamicProto(PerfManager, this, function (_self) {\n      _self.create = function (src, payloadDetails, isAsync) {\n        // TODO (@MSNev): at some point we will want to add additional configuration to \"select\" which events to instrument\n        // for now this is just a simple do everything.\n        return new PerfEvent(src, payloadDetails, isAsync);\n      };\n\n      _self.fire = function (perfEvent) {\n        if (perfEvent) {\n          perfEvent[_DYN_COMPLETE\n          /* @min:%2ecomplete */\n          ]();\n\n          if (manager && isFunction(manager[STR_PERF_EVENT\n          /* @min:%2eperfEvent */\n          ])) {\n            manager[STR_PERF_EVENT\n            /* @min:%2eperfEvent */\n            ](perfEvent);\n          }\n        }\n      };\n\n      _self[_DYN_SET_CTX\n      /* @min:%2esetCtx */\n      ] = function (key, value) {\n        if (key) {\n          var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\n          ctx[key] = value;\n        }\n      };\n\n      _self[_DYN_GET_CTX\n      /* @min:%2egetCtx */\n      ] = function (key) {\n        return (_self[strExecutionContextKey] || {})[key];\n      };\n    });\n  } // Removed Stub for PerfManager.prototype.create.\n  // Removed Stub for PerfManager.prototype.fire.\n  // Removed Stub for PerfManager.prototype.setCtx.\n  // Removed Stub for PerfManager.prototype.getCtx.\n  // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  // this will be removed when ES3 support is dropped.\n\n\n  PerfManager.__ieDyn = 1;\n  return PerfManager;\n}();\n\nexport { PerfManager };\nvar doPerfActiveKey = \"CoreUtils.doPerf\";\n/**\r\n * Helper function to wrap a function with a perf event\r\n * @param mgrSource - The Performance Manager or a Performance provider source (may be null)\r\n * @param getSource - The callback to create the source name for the event (if perf monitoring is enabled)\r\n * @param func - The function to call and measure\r\n * @param details - A function to return the payload details\r\n * @param isAsync - Is the event / function being call asynchronously or synchronously\r\n */\n\nexport function doPerf(mgrSource, getSource, func, details, isAsync) {\n  if (mgrSource) {\n    var perfMgr = mgrSource;\n\n    if (perfMgr[STR_GET_PERF_MGR]) {\n      // Looks like a perf manager provider object\n      perfMgr = perfMgr[STR_GET_PERF_MGR]();\n    }\n\n    if (perfMgr) {\n      var perfEvt = void 0;\n\n      var currentActive = perfMgr[_DYN_GET_CTX\n      /* @min:%2egetCtx */\n      ](doPerfActiveKey);\n\n      try {\n        perfEvt = perfMgr.create(getSource(), details, isAsync);\n\n        if (perfEvt) {\n          if (currentActive && perfEvt[_DYN_SET_CTX\n          /* @min:%2esetCtx */\n          ]) {\n            perfEvt[_DYN_SET_CTX\n            /* @min:%2esetCtx */\n            ](PerfEvent[strParentContextKey], currentActive);\n\n            if (currentActive[_DYN_GET_CTX\n            /* @min:%2egetCtx */\n            ] && currentActive[_DYN_SET_CTX\n            /* @min:%2esetCtx */\n            ]) {\n              var children = currentActive[_DYN_GET_CTX\n              /* @min:%2egetCtx */\n              ](PerfEvent[strChildrenContextKey]);\n\n              if (!children) {\n                children = [];\n\n                currentActive[_DYN_SET_CTX\n                /* @min:%2esetCtx */\n                ](PerfEvent[strChildrenContextKey], children);\n              }\n\n              children[_DYN_PUSH\n              /* @min:%2epush */\n              ](perfEvt);\n            }\n          } // Set this event as the active event now\n\n\n          perfMgr[_DYN_SET_CTX\n          /* @min:%2esetCtx */\n          ](doPerfActiveKey, perfEvt);\n\n          return func(perfEvt);\n        }\n      } catch (ex) {\n        if (perfEvt && perfEvt[_DYN_SET_CTX\n        /* @min:%2esetCtx */\n        ]) {\n          perfEvt[_DYN_SET_CTX\n          /* @min:%2esetCtx */\n          ](\"exception\", ex);\n        }\n      } finally {\n        // fire the perf event\n        if (perfEvt) {\n          perfMgr.fire(perfEvt);\n        } // Reset the active event to the previous value\n\n\n        perfMgr[_DYN_SET_CTX\n        /* @min:%2esetCtx */\n        ](doPerfActiveKey, currentActive);\n      }\n    }\n  }\n\n  return func();\n}\n/**\r\n * Set the global performance manager to use when there is no core instance or it has not been initialized yet.\r\n * @param perfManager - The IPerfManager instance to use when no performance manager is supplied.\r\n */\n\nexport function setGblPerfMgr(perfManager) {\n  _defaultPerfManager = perfManager;\n}\n/**\r\n * Get the current global performance manager that will be used with no performance manager is supplied.\r\n * @returns - The current default manager\r\n */\n\nexport function getGblPerfMgr() {\n  return _defaultPerfManager;\n} //# sourceMappingURL=PerfManager.js.map","map":null,"metadata":{},"sourceType":"module"}