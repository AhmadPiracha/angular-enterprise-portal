{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Dependencies Plugin, 2.8.18\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nimport { __assignFn as __assign, __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { CorrelationIdHelper, DisabledPropertyName, PropertiesPluginIdentifier, RemoteDependencyData, RequestHeaders, createDistributedTraceContextFromTrace, createTelemetryItem, createTraceParent, dateTimeUtilsNow, formatTraceParent, isInternalApplicationInsightsEndpoint } from \"@microsoft/applicationinsights-common\";\nimport { BaseTelemetryPlugin, InstrumentFunc, InstrumentProto, _throwInternal, arrForEach, createProcessTelemetryContext, createUniqueNamespace, deepFreeze, dumpObj, eventOn, generateW3CId, getExceptionName, getGlobal, getIEVersion, getLocation, getPerformance, isFunction, isNullOrUndefined, isString, isXhrSupported, mergeEvtNamespace, objForEachKey, strPrototype, strTrim } from \"@microsoft/applicationinsights-core-js\";\nimport { STR_PROPERTIES } from \"./InternalConstants\";\nimport { _DYN_ABORTED, _DYN_ABORT_DONE, _DYN_ADD_REQUEST_CONTEXT, _DYN_AJAX_PERF_LOOKUP_DEL18, _DYN_APP_ID, _DYN_CAN_INCLUDE_CORRELAT3, _DYN_CONTEXT, _DYN_CORE, _DYN_DISABLE_AJAX_TRACKIN12, _DYN_DISABLE_FETCH_TRACKI13, _DYN_DISTRIBUTED_TRACING_5, _DYN_ENABLE_AJAX_ERROR_ST7, _DYN_ENABLE_AJAX_PERF_TRA8, _DYN_ENABLE_REQUEST_HEADE6, _DYN_ENABLE_RESPONSE_HEAD10, _DYN_ERROR_STATUS_TEXT, _DYN_EXCLUDE_REQUEST_FROM11, _DYN_GET_ABSOLUTE_URL, _DYN_GET_ALL_RESPONSE_HEA16, _DYN_GET_CORRELATION_CONT17, _DYN_GET_PART_APROPS, _DYN_GET_TRACE_FLAGS, _DYN_GET_TRACE_ID, _DYN_HEADERS, _DYN_HEADER_MAP, _DYN_INCLUDE_CORRELATION_2, _DYN_INST, _DYN_LENGTH, _DYN_MAX_AJAX_CALLS_PER_V9, _DYN_METHOD, _DYN_NAME, _DYN_OPEN_DONE, _DYN_PERF_MARK, _DYN_PERF_TIMING, _DYN_REQUEST_HEADERS, _DYN_REQUEST_SENT_TIME, _DYN_REQUEST_URL, _DYN_RESPONSE, _DYN_RESPONSE_FINISHED_TI15, _DYN_RESPONSE_TEXT, _DYN_SEND_DONE, _DYN_SET_REQUEST_HEADER, _DYN_SPAN_ID, _DYN_SPAN_ID1, _DYN_START_TIME, _DYN_STATE_CHANGE_ATTACHE14, _DYN_STATUS, _DYN_STATUS_TEXT, _DYN_TO_LOWER_CASE, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN_TRACE_ID0, _DYN_TRACK_DEPENDENCY_DAT4, _DYN__CREATE_TRACK_ITEM } from \"./__DynamicConstants\";\nimport { ajaxRecord } from \"./ajaxRecord\";\nvar AJAX_MONITOR_PREFIX = \"ai.ajxmn.\";\nvar strDiagLog = \"diagLog\";\nvar AJAX_DATA_CONTAINER = \"_ajaxData\";\nvar STR_FETCH = \"fetch\";\nvar ERROR_HEADER = \"Failed to monitor XMLHttpRequest\";\nvar ERROR_PREFIX = \", monitoring data for this ajax call \";\nvar ERROR_POSTFIX = ERROR_PREFIX + \"may be incorrect.\";\nvar ERROR_NOT_SENT = ERROR_PREFIX + \"won't be sent.\";\nvar CORRELATION_HEADER_ERROR = \"Failed to get Request-Context correlation header as it may be not included in the response or not accessible.\";\nvar CUSTOM_REQUEST_CONTEXT_ERROR = \"Failed to add custom defined request context as configured call back may missing a null check.\";\nvar FAILED_TO_CALCULATE_DURATION_ERROR = \"Failed to calculate the duration of the \"; // Using a global value so that to handle same iKey with multiple app insights instances (mostly for testing)\n\nvar _markCount = 0;\n/** @Ignore */\n\nfunction _supportsFetch() {\n  var _global = getGlobal();\n\n  if (!_global || isNullOrUndefined(_global.Request) || isNullOrUndefined(_global.Request[strPrototype]) || isNullOrUndefined(_global[STR_FETCH])) {\n    return null;\n  }\n\n  return _global[STR_FETCH];\n}\n\nvar _isWebWorker = null;\n\nfunction isWebWorker() {\n  if (_isWebWorker == null) {\n    try {\n      _isWebWorker = !!(self && self instanceof WorkerGlobalScope);\n    } catch (e) {\n      _isWebWorker = false;\n    }\n  }\n\n  return _isWebWorker;\n}\n/**\r\n * Determines whether ajax monitoring can be enabled on this document\r\n * @returns True if Ajax monitoring is supported on this page, otherwise false\r\n * @ignore\r\n */\n\n\nfunction _supportsAjaxMonitoring(ajaxMonitorInstance, ajaxDataId) {\n  var _a;\n\n  var result = false;\n\n  if (isXhrSupported()) {\n    var proto = XMLHttpRequest[strPrototype];\n    result = !isNullOrUndefined(proto) && !isNullOrUndefined(proto.open) && // eslint-disable-line security/detect-non-literal-fs-filename -- false positive\n    !isNullOrUndefined(proto.send) && !isNullOrUndefined(proto.abort);\n  }\n\n  var ieVer = getIEVersion();\n\n  if (ieVer && ieVer < 9) {\n    result = false;\n  }\n\n  if (result) {\n    // Disable if the XmlHttpRequest can't be extended or hooked\n    try {\n      var xhr = new XMLHttpRequest();\n      var xhrData = {\n        xh: [],\n        i: (_a = {}, _a[ajaxDataId] = {}, _a)\n      };\n      xhr[AJAX_DATA_CONTAINER] = xhrData; // Check that we can update the prototype\n\n      var theOpen = XMLHttpRequest[strPrototype].open;\n      XMLHttpRequest[strPrototype].open = theOpen;\n    } catch (e) {\n      // We can't decorate the xhr object so disable monitoring\n      result = false;\n\n      _throwInternalCritical(ajaxMonitorInstance, 15\n      /* _eInternalMessageId.FailedMonitorAjaxOpen */\n      , \"Failed to enable XMLHttpRequest monitoring, extension is not supported\", {\n        exception: dumpObj(e)\n      });\n    }\n  }\n\n  return result;\n}\n/**\r\n * Internal helper to fetch the SDK instance tracking data for this XHR request\r\n * @param xhr\r\n * @param ajaxDataId\r\n * @returns\r\n */\n\n\nvar _getAjaxData = function (xhr, ajaxDataId) {\n  if (xhr && ajaxDataId && xhr[AJAX_DATA_CONTAINER]) {\n    return (xhr[AJAX_DATA_CONTAINER].i || {})[ajaxDataId];\n  }\n\n  return null;\n};\n/**\r\n * @ignore\r\n * Internal helper to track the singleton shared tracking headers, so we can attempt to not create headers\r\n * that might cause an issue if multiple values are populated.\r\n * @param xhr - The instrumented XHR instance\r\n */\n\n\nvar _addSharedXhrHeaders = function (xhr, name, value) {\n  if (xhr) {\n    var headers = (xhr[AJAX_DATA_CONTAINER] || {}).xh;\n\n    if (headers) {\n      headers.push({\n        n: name,\n        v: value\n      });\n    }\n  }\n};\n\nvar _isHeaderSet = function (xhr, name) {\n  var isPresent = false;\n\n  if (xhr) {\n    var headers = (xhr[AJAX_DATA_CONTAINER] || {}).xh;\n\n    if (headers) {\n      arrForEach(headers, function (header) {\n        if (header.n === name) {\n          isPresent = true;\n          return -1;\n        }\n      });\n    }\n  }\n\n  return isPresent;\n};\n/** @Ignore */\n\n\nfunction _getFailedAjaxDiagnosticsMessage(xhr, ajaxDataId) {\n  var result = \"\";\n\n  try {\n    var ajaxData = _getAjaxData(xhr, ajaxDataId);\n\n    if (ajaxData && ajaxData[_DYN_REQUEST_URL\n    /* @min:%2erequestUrl */\n    ]) {\n      result += \"(url: '\" + ajaxData[_DYN_REQUEST_URL\n      /* @min:%2erequestUrl */\n      ] + \"')\";\n    }\n  } catch (e) {// eslint-disable-next-line no-empty\n  }\n\n  return result;\n}\n/** @ignore */\n\n\nfunction _throwInternalCritical(ajaxMonitorInstance, msgId, message, properties, isUserAct) {\n  _throwInternal(ajaxMonitorInstance[strDiagLog](), 1\n  /* eLoggingSeverity.CRITICAL */\n  , msgId, message, properties, isUserAct);\n}\n/** @ignore */\n\n\nfunction _throwInternalWarning(ajaxMonitorInstance, msgId, message, properties, isUserAct) {\n  _throwInternal(ajaxMonitorInstance[strDiagLog](), 2\n  /* eLoggingSeverity.WARNING */\n  , msgId, message, properties, isUserAct);\n}\n/** @Ignore */\n\n\nfunction _createErrorCallbackFunc(ajaxMonitorInstance, internalMessage, message) {\n  // tslint:disable-next-line\n  return function (callDetails) {\n    _throwInternalCritical(ajaxMonitorInstance, internalMessage, message, {\n      ajaxDiagnosticsMessage: _getFailedAjaxDiagnosticsMessage(callDetails[_DYN_INST\n      /* @min:%2einst */\n      ], ajaxMonitorInstance._ajaxDataId),\n      exception: dumpObj(callDetails.err)\n    });\n  };\n}\n\nfunction _indexOf(value, match) {\n  if (value && match) {\n    return value.indexOf(match);\n  }\n\n  return -1;\n}\n\nfunction _addHandler(container, id, theFunc) {\n  var theHandler = {\n    id: id,\n    fn: theFunc\n  };\n  container.push(theHandler);\n  return {\n    remove: function () {\n      arrForEach(container, function (initializer, idx) {\n        if (initializer.id === theHandler.id) {\n          container.splice(idx, 1);\n          return -1;\n        }\n      });\n    }\n  };\n}\n\nfunction _processDependencyContainer(core, container, details, message) {\n  var result = true;\n  arrForEach(container, function (theFunc, idx) {\n    try {\n      if (theFunc.fn.call(null, details) === false) {\n        result = false;\n      }\n    } catch (e) {\n      _throwInternal(core && core.logger, 1\n      /* eLoggingSeverity.CRITICAL */\n      , 64\n      /* _eInternalMessageId.TelemetryInitializerFailed */\n      , \"Dependency \" + message + \" [#\" + idx + \"] failed: \" + getExceptionName(e), {\n        exception: dumpObj(e)\n      }, true);\n    }\n  });\n  return result;\n}\n\nfunction _processDependencyListeners(listeners, core, ajaxData, xhr, input, init) {\n  var initializersCount = listeners[_DYN_LENGTH\n  /* @min:%2elength */\n  ];\n\n  if (initializersCount > 0) {\n    var details = {\n      core: core,\n      xhr: xhr,\n      input: input,\n      init: init,\n      traceId: ajaxData[_DYN_TRACE_ID\n      /* @min:%2etraceID */\n      ],\n      spanId: ajaxData[_DYN_SPAN_ID\n      /* @min:%2espanID */\n      ],\n      traceFlags: ajaxData[_DYN_TRACE_FLAGS\n      /* @min:%2etraceFlags */\n      ],\n      context: ajaxData[_DYN_CONTEXT\n      /* @min:%2econtext */\n      ] || {},\n      aborted: !!ajaxData[_DYN_ABORTED\n      /* @min:%2eaborted */\n      ]\n    };\n\n    _processDependencyContainer(core, listeners, details, \"listener\");\n\n    ajaxData[_DYN_TRACE_ID\n    /* @min:%2etraceID */\n    ] = details[_DYN_TRACE_ID0\n    /* @min:%2etraceId */\n    ];\n    ajaxData[_DYN_SPAN_ID\n    /* @min:%2espanID */\n    ] = details[_DYN_SPAN_ID1\n    /* @min:%2espanId */\n    ];\n    ajaxData[_DYN_TRACE_FLAGS\n    /* @min:%2etraceFlags */\n    ] = details[_DYN_TRACE_FLAGS\n    /* @min:%2etraceFlags */\n    ];\n    ajaxData[_DYN_CONTEXT\n    /* @min:%2econtext */\n    ] = details[_DYN_CONTEXT\n    /* @min:%2econtext */\n    ];\n  }\n}\n\nvar BLOB_CORE = \"*.blob.core.\";\nexport var DfltAjaxCorrelationHeaderExDomains = deepFreeze([BLOB_CORE + \"windows.net\", BLOB_CORE + \"chinacloudapi.cn\", BLOB_CORE + \"cloudapi.de\", BLOB_CORE + \"usgovcloudapi.net\"]);\nvar _internalExcludeEndpoints = [/https:\\/\\/[^\\/]*(\\.pipe\\.aria|aria\\.pipe|events\\.data|collector\\.azure)\\.[^\\/]+\\/(OneCollector\\/1|Collector\\/3)\\.0/i];\n\nfunction _getDefaultConfig() {\n  var config = {\n    maxAjaxCallsPerView: 500,\n    disableAjaxTracking: false,\n    disableFetchTracking: false,\n    excludeRequestFromAutoTrackingPatterns: undefined,\n    disableCorrelationHeaders: false,\n    distributedTracingMode: 1\n    /* eDistributedTracingModes.AI_AND_W3C */\n    ,\n    correlationHeaderExcludedDomains: DfltAjaxCorrelationHeaderExDomains,\n    correlationHeaderDomains: undefined,\n    correlationHeaderExcludePatterns: undefined,\n    appId: undefined,\n    enableCorsCorrelation: false,\n    enableRequestHeaderTracking: false,\n    enableResponseHeaderTracking: false,\n    enableAjaxErrorStatusText: false,\n    enableAjaxPerfTracking: false,\n    maxAjaxPerfLookupAttempts: 3,\n    ajaxPerfLookupDelay: 25,\n    ignoreHeaders: [\"Authorization\", \"X-API-Key\", \"WWW-Authenticate\"],\n    addRequestContext: undefined,\n    addIntEndpoints: true\n  };\n  return config;\n}\n\nfunction _getEmptyConfig() {\n  var emptyConfig = _getDefaultConfig();\n\n  objForEachKey(emptyConfig, function (value) {\n    emptyConfig[value] = undefined;\n  });\n  return emptyConfig;\n}\n\nvar AjaxMonitor =\n/** @class */\nfunction (_super) {\n  __extends(AjaxMonitor, _super);\n\n  function AjaxMonitor() {\n    var _this = _super.call(this) || this;\n\n    _this.identifier = AjaxMonitor.identifier;\n    _this.priority = 120;\n\n    var _fetchInitialized; // fetch monitoring initialized\n\n\n    var _xhrInitialized; // XHR monitoring initialized\n\n\n    var _currentWindowHost;\n\n    var _config;\n\n    var _enableRequestHeaderTracking;\n\n    var _enableAjaxErrorStatusText;\n\n    var _trackAjaxAttempts;\n\n    var _context;\n\n    var _isUsingW3CHeaders;\n\n    var _isUsingAIHeaders;\n\n    var _markPrefix;\n\n    var _enableAjaxPerfTracking;\n\n    var _maxAjaxCallsPerView;\n\n    var _enableResponseHeaderTracking;\n\n    var _disabledUrls;\n\n    var _disableAjaxTracking;\n\n    var _disableFetchTracking;\n\n    var _excludeRequestFromAutoTrackingPatterns;\n\n    var _addRequestContext;\n\n    var _evtNamespace;\n\n    var _ajaxDataId;\n\n    var _dependencyHandlerId;\n\n    var _dependencyListeners;\n\n    var _dependencyInitializers;\n\n    dynamicProto(AjaxMonitor, _this, function (_self, _base) {\n      var _addHook = _base._addHook;\n\n      _initDefaults();\n\n      _self.initialize = function (config, core, extensions, pluginChain) {\n        if (!_self.isInitialized()) {\n          _base.initialize(config, core, extensions, pluginChain);\n\n          _evtNamespace = mergeEvtNamespace(createUniqueNamespace(\"ajax\"), core && core.evtNamespace && core.evtNamespace());\n\n          _populateDefaults(config);\n\n          _instrumentXhr();\n\n          _instrumentFetch();\n\n          _populateContext();\n        }\n      };\n\n      _self._doTeardown = function () {\n        _initDefaults();\n      };\n\n      _self.trackDependencyData = function (dependency, properties) {\n        _reportDependencyInternal(_dependencyInitializers, _self[_DYN_CORE\n        /* @min:%2ecore */\n        ], null, dependency, properties);\n      };\n\n      _self[_DYN_INCLUDE_CORRELATION_2\n      /* @min:%2eincludeCorrelationHeaders */\n      ] = function (ajaxData, input, init, xhr) {\n        // Test Hook to allow the overriding of the location host\n        var currentWindowHost = _self[\"_currentWindowHost\"] || _currentWindowHost;\n\n        _processDependencyListeners(_dependencyListeners, _self[_DYN_CORE\n        /* @min:%2ecore */\n        ], ajaxData, xhr, input, init);\n\n        if (input || input === \"\") {\n          // Fetch\n          if (CorrelationIdHelper[_DYN_CAN_INCLUDE_CORRELAT3\n          /* @min:%2ecanIncludeCorrelationHeader */\n          ](_config, ajaxData[_DYN_GET_ABSOLUTE_URL\n          /* @min:%2egetAbsoluteUrl */\n          ](), currentWindowHost)) {\n            if (!init) {\n              init = {};\n            } // init headers override original request headers\n            // so, if they exist use only them, otherwise use request's because they should have been applied in the first place\n            // not using original request headers will result in them being lost\n\n\n            var headers = new Headers(init[_DYN_HEADERS\n            /* @min:%2eheaders */\n            ] || (input instanceof Request ? input[_DYN_HEADERS\n            /* @min:%2eheaders */\n            ] || {} : {}));\n\n            if (_isUsingAIHeaders) {\n              var id = \"|\" + ajaxData[_DYN_TRACE_ID\n              /* @min:%2etraceID */\n              ] + \".\" + ajaxData[_DYN_SPAN_ID\n              /* @min:%2espanID */\n              ];\n              headers.set(RequestHeaders[3\n              /* eRequestHeaders.requestIdHeader */\n              ], id);\n\n              if (_enableRequestHeaderTracking) {\n                ajaxData[_DYN_REQUEST_HEADERS\n                /* @min:%2erequestHeaders */\n                ][RequestHeaders[3\n                /* eRequestHeaders.requestIdHeader */\n                ]] = id;\n              }\n            }\n\n            var appId = _config[_DYN_APP_ID\n            /* @min:%2eappId */\n            ] || _context && _context[_DYN_APP_ID\n            /* @min:%2eappId */\n            ]();\n\n            if (appId) {\n              headers.set(RequestHeaders[0\n              /* eRequestHeaders.requestContextHeader */\n              ], RequestHeaders[2\n              /* eRequestHeaders.requestContextAppIdFormat */\n              ] + appId);\n\n              if (_enableRequestHeaderTracking) {\n                ajaxData[_DYN_REQUEST_HEADERS\n                /* @min:%2erequestHeaders */\n                ][RequestHeaders[0\n                /* eRequestHeaders.requestContextHeader */\n                ]] = RequestHeaders[2\n                /* eRequestHeaders.requestContextAppIdFormat */\n                ] + appId;\n              }\n            }\n\n            if (_isUsingW3CHeaders) {\n              var traceFlags = ajaxData[_DYN_TRACE_FLAGS\n              /* @min:%2etraceFlags */\n              ];\n\n              if (isNullOrUndefined(traceFlags)) {\n                traceFlags = 0x01;\n              }\n\n              var traceParent = formatTraceParent(createTraceParent(ajaxData[_DYN_TRACE_ID\n              /* @min:%2etraceID */\n              ], ajaxData[_DYN_SPAN_ID\n              /* @min:%2espanID */\n              ], traceFlags));\n              headers.set(RequestHeaders[4\n              /* eRequestHeaders.traceParentHeader */\n              ], traceParent);\n\n              if (_enableRequestHeaderTracking) {\n                ajaxData[_DYN_REQUEST_HEADERS\n                /* @min:%2erequestHeaders */\n                ][RequestHeaders[4\n                /* eRequestHeaders.traceParentHeader */\n                ]] = traceParent;\n              }\n            }\n\n            init[_DYN_HEADERS\n            /* @min:%2eheaders */\n            ] = headers;\n          }\n\n          return init;\n        } else if (xhr) {\n          // XHR\n          if (CorrelationIdHelper[_DYN_CAN_INCLUDE_CORRELAT3\n          /* @min:%2ecanIncludeCorrelationHeader */\n          ](_config, ajaxData[_DYN_GET_ABSOLUTE_URL\n          /* @min:%2egetAbsoluteUrl */\n          ](), currentWindowHost)) {\n            if (_isUsingAIHeaders) {\n              if (!_isHeaderSet(xhr, RequestHeaders[3\n              /* eRequestHeaders.requestIdHeader */\n              ])) {\n                var id = \"|\" + ajaxData[_DYN_TRACE_ID\n                /* @min:%2etraceID */\n                ] + \".\" + ajaxData[_DYN_SPAN_ID\n                /* @min:%2espanID */\n                ];\n\n                xhr[_DYN_SET_REQUEST_HEADER\n                /* @min:%2esetRequestHeader */\n                ](RequestHeaders[3\n                /* eRequestHeaders.requestIdHeader */\n                ], id);\n\n                if (_enableRequestHeaderTracking) {\n                  ajaxData[_DYN_REQUEST_HEADERS\n                  /* @min:%2erequestHeaders */\n                  ][RequestHeaders[3\n                  /* eRequestHeaders.requestIdHeader */\n                  ]] = id;\n                }\n              } else {\n                _throwInternalWarning(_self, 71\n                /* _eInternalMessageId.FailedMonitorAjaxSetRequestHeader */\n                , \"Unable to set [\" + RequestHeaders[3\n                /* eRequestHeaders.requestIdHeader */\n                ] + \"] as it has already been set by another instance\");\n              }\n            }\n\n            var appId = _config[_DYN_APP_ID\n            /* @min:%2eappId */\n            ] || _context && _context[_DYN_APP_ID\n            /* @min:%2eappId */\n            ]();\n\n            if (appId) {\n              if (!_isHeaderSet(xhr, RequestHeaders[0\n              /* eRequestHeaders.requestContextHeader */\n              ])) {\n                xhr[_DYN_SET_REQUEST_HEADER\n                /* @min:%2esetRequestHeader */\n                ](RequestHeaders[0\n                /* eRequestHeaders.requestContextHeader */\n                ], RequestHeaders[2\n                /* eRequestHeaders.requestContextAppIdFormat */\n                ] + appId);\n\n                if (_enableRequestHeaderTracking) {\n                  ajaxData[_DYN_REQUEST_HEADERS\n                  /* @min:%2erequestHeaders */\n                  ][RequestHeaders[0\n                  /* eRequestHeaders.requestContextHeader */\n                  ]] = RequestHeaders[2\n                  /* eRequestHeaders.requestContextAppIdFormat */\n                  ] + appId;\n                }\n              } else {\n                _throwInternalWarning(_self, 71\n                /* _eInternalMessageId.FailedMonitorAjaxSetRequestHeader */\n                , \"Unable to set [\" + RequestHeaders[0\n                /* eRequestHeaders.requestContextHeader */\n                ] + \"] as it has already been set by another instance\");\n              }\n            }\n\n            if (_isUsingW3CHeaders) {\n              var traceFlags = ajaxData[_DYN_TRACE_FLAGS\n              /* @min:%2etraceFlags */\n              ];\n\n              if (isNullOrUndefined(traceFlags)) {\n                traceFlags = 0x01;\n              }\n\n              if (!_isHeaderSet(xhr, RequestHeaders[4\n              /* eRequestHeaders.traceParentHeader */\n              ])) {\n                var traceParent = formatTraceParent(createTraceParent(ajaxData[_DYN_TRACE_ID\n                /* @min:%2etraceID */\n                ], ajaxData[_DYN_SPAN_ID\n                /* @min:%2espanID */\n                ], traceFlags));\n\n                xhr[_DYN_SET_REQUEST_HEADER\n                /* @min:%2esetRequestHeader */\n                ](RequestHeaders[4\n                /* eRequestHeaders.traceParentHeader */\n                ], traceParent);\n\n                if (_enableRequestHeaderTracking) {\n                  ajaxData[_DYN_REQUEST_HEADERS\n                  /* @min:%2erequestHeaders */\n                  ][RequestHeaders[4\n                  /* eRequestHeaders.traceParentHeader */\n                  ]] = traceParent;\n                }\n              } else {\n                _throwInternalWarning(_self, 71\n                /* _eInternalMessageId.FailedMonitorAjaxSetRequestHeader */\n                , \"Unable to set [\" + RequestHeaders[4\n                /* eRequestHeaders.traceParentHeader */\n                ] + \"] as it has already been set by another instance\");\n              }\n            }\n          }\n\n          return xhr;\n        }\n\n        return undefined;\n      };\n\n      _self[_DYN_TRACK_DEPENDENCY_DAT4\n      /* @min:%2etrackDependencyDataInternal */\n      ] = function (dependency, properties, systemProperties) {\n        if (_maxAjaxCallsPerView === -1 || _trackAjaxAttempts < _maxAjaxCallsPerView) {\n          // Hack since expected format in w3c mode is |abc.def.\n          // Non-w3c format is |abc.def\n          // @todo Remove if better solution is available, e.g. handle in portal\n          if ((_config[_DYN_DISTRIBUTED_TRACING_5\n          /* @min:%2edistributedTracingMode */\n          ] === 2\n          /* eDistributedTracingModes.W3C */\n          || _config[_DYN_DISTRIBUTED_TRACING_5\n          /* @min:%2edistributedTracingMode */\n          ] === 1\n          /* eDistributedTracingModes.AI_AND_W3C */\n          ) && typeof dependency.id === \"string\" && dependency.id[dependency.id[_DYN_LENGTH\n          /* @min:%2elength */\n          ] - 1] !== \".\") {\n            dependency.id += \".\";\n          }\n\n          if (isNullOrUndefined(dependency[_DYN_START_TIME\n          /* @min:%2estartTime */\n          ])) {\n            dependency[_DYN_START_TIME\n            /* @min:%2estartTime */\n            ] = new Date();\n          }\n\n          var item = createTelemetryItem(dependency, RemoteDependencyData.dataType, RemoteDependencyData.envelopeType, _self[strDiagLog](), properties, systemProperties);\n\n          _self[_DYN_CORE\n          /* @min:%2ecore */\n          ].track(item);\n        } else if (_trackAjaxAttempts === _maxAjaxCallsPerView) {\n          _throwInternalCritical(_self, 55\n          /* _eInternalMessageId.MaxAjaxPerPVExceeded */\n          , \"Maximum ajax per page view limit reached, ajax monitoring is paused until the next trackPageView(). In order to increase the limit set the maxAjaxCallsPerView configuration parameter.\", true);\n        }\n\n        ++_trackAjaxAttempts;\n      };\n\n      _self.addDependencyListener = function (dependencyListener) {\n        return _addHandler(_dependencyListeners, _dependencyHandlerId++, dependencyListener);\n      };\n\n      _self.addDependencyInitializer = function (dependencyInitializer) {\n        return _addHandler(_dependencyInitializers, _dependencyHandlerId++, dependencyInitializer);\n      };\n\n      function _initDefaults() {\n        var location = getLocation();\n        _fetchInitialized = false; // fetch monitoring initialized\n\n        _xhrInitialized = false; // XHR monitoring initialized\n\n        _currentWindowHost = location && location.host && location.host[_DYN_TO_LOWER_CASE\n        /* @min:%2etoLowerCase */\n        ]();\n        _config = AjaxMonitor.getEmptyConfig();\n        _enableRequestHeaderTracking = false;\n        _enableAjaxErrorStatusText = false;\n        _trackAjaxAttempts = 0;\n        _context = null;\n        _isUsingW3CHeaders = false;\n        _isUsingAIHeaders = false;\n        _markPrefix = null;\n        _enableAjaxPerfTracking = false;\n        _maxAjaxCallsPerView = 0;\n        _enableResponseHeaderTracking = false;\n        _disabledUrls = {};\n        _disableAjaxTracking = false;\n        _disableFetchTracking = false;\n        _excludeRequestFromAutoTrackingPatterns = null;\n        _addRequestContext = null;\n        _evtNamespace = null;\n        _dependencyHandlerId = 0;\n        _dependencyListeners = [];\n        _dependencyInitializers = [];\n        _ajaxDataId = createUniqueNamespace(\"ajaxData\");\n        _self._ajaxDataId = _ajaxDataId;\n      }\n\n      function _populateDefaults(config) {\n        var ctx = createProcessTelemetryContext(null, config, _self[_DYN_CORE\n        /* @min:%2ecore */\n        ]); // Reset to the empty config\n\n        _config = _getEmptyConfig();\n\n        var defaultConfig = _getDefaultConfig();\n\n        objForEachKey(defaultConfig, function (field, value) {\n          _config[field] = ctx.getConfig(AjaxMonitor.identifier, field, value);\n        });\n        var distributedTracingMode = _config[_DYN_DISTRIBUTED_TRACING_5\n        /* @min:%2edistributedTracingMode */\n        ];\n        _enableRequestHeaderTracking = _config[_DYN_ENABLE_REQUEST_HEADE6\n        /* @min:%2eenableRequestHeaderTracking */\n        ];\n        _enableAjaxErrorStatusText = _config[_DYN_ENABLE_AJAX_ERROR_ST7\n        /* @min:%2eenableAjaxErrorStatusText */\n        ];\n        _enableAjaxPerfTracking = _config[_DYN_ENABLE_AJAX_PERF_TRA8\n        /* @min:%2eenableAjaxPerfTracking */\n        ];\n        _maxAjaxCallsPerView = _config[_DYN_MAX_AJAX_CALLS_PER_V9\n        /* @min:%2emaxAjaxCallsPerView */\n        ];\n        _enableResponseHeaderTracking = _config[_DYN_ENABLE_RESPONSE_HEAD10\n        /* @min:%2eenableResponseHeaderTracking */\n        ];\n        _excludeRequestFromAutoTrackingPatterns = [].concat(_config[_DYN_EXCLUDE_REQUEST_FROM11\n        /* @min:%2eexcludeRequestFromAutoTrackingPatterns */\n        ] || [], _config.addIntEndpoints !== false ? _internalExcludeEndpoints : []);\n        _addRequestContext = _config[_DYN_ADD_REQUEST_CONTEXT\n        /* @min:%2eaddRequestContext */\n        ];\n        _isUsingAIHeaders = distributedTracingMode === 0\n        /* eDistributedTracingModes.AI */\n        || distributedTracingMode === 1\n        /* eDistributedTracingModes.AI_AND_W3C */\n        ;\n        _isUsingW3CHeaders = distributedTracingMode === 1\n        /* eDistributedTracingModes.AI_AND_W3C */\n        || distributedTracingMode === 2\n        /* eDistributedTracingModes.W3C */\n        ;\n\n        if (_enableAjaxPerfTracking) {\n          var iKey = config.instrumentationKey || \"unkwn\";\n\n          if (iKey[_DYN_LENGTH\n          /* @min:%2elength */\n          ] > 5) {\n            _markPrefix = AJAX_MONITOR_PREFIX + iKey.substring(iKey[_DYN_LENGTH\n            /* @min:%2elength */\n            ] - 5) + \".\";\n          } else {\n            _markPrefix = AJAX_MONITOR_PREFIX + iKey + \".\";\n          }\n        }\n\n        _disableAjaxTracking = !!_config[_DYN_DISABLE_AJAX_TRACKIN12\n        /* @min:%2edisableAjaxTracking */\n        ];\n        _disableFetchTracking = !!_config[_DYN_DISABLE_FETCH_TRACKI13\n        /* @min:%2edisableFetchTracking */\n        ];\n      }\n\n      function _populateContext() {\n        var propExt = _self[_DYN_CORE\n        /* @min:%2ecore */\n        ].getPlugin(PropertiesPluginIdentifier);\n\n        if (propExt) {\n          _context = propExt.plugin[_DYN_CONTEXT\n          /* @min:%2econtext */\n          ]; // we could move IPropertiesPlugin to common as well\n        }\n      } // discard the header if it's defined as ignoreHeaders in ICorrelationConfig\n\n\n      function _canIncludeHeaders(header) {\n        var rlt = true;\n\n        if (header || _config.ignoreHeaders) {\n          arrForEach(_config.ignoreHeaders, function (key) {\n            if (key[_DYN_TO_LOWER_CASE\n            /* @min:%2etoLowerCase */\n            ]() === header[_DYN_TO_LOWER_CASE\n            /* @min:%2etoLowerCase */\n            ]()) {\n              rlt = false;\n              return -1;\n            }\n          });\n        }\n\n        return rlt;\n      } // Fetch Stuff\n\n\n      function _instrumentFetch() {\n        var fetch = _supportsFetch();\n\n        if (!fetch) {\n          return;\n        }\n\n        var global = getGlobal();\n        var isPolyfill = fetch.polyfill;\n\n        if (!_disableFetchTracking && !_fetchInitialized) {\n          _addHook(InstrumentFunc(global, STR_FETCH, {\n            ns: _evtNamespace,\n            // Add request hook\n            req: function (callDetails, input, init) {\n              var fetchData;\n\n              if (!_disableFetchTracking && _fetchInitialized && !_isDisabledRequest(null, input, init) && // If we have a polyfil and XHR instrumented then let XHR report otherwise we get duplicates\n              !(isPolyfill && _xhrInitialized)) {\n                var ctx = callDetails.ctx();\n                fetchData = _createFetchRecord(input, init);\n\n                var newInit = _self[_DYN_INCLUDE_CORRELATION_2\n                /* @min:%2eincludeCorrelationHeaders */\n                ](fetchData, input, init);\n\n                if (newInit !== init) {\n                  callDetails.set(1, newInit);\n                }\n\n                ctx.data = fetchData;\n              }\n            },\n            rsp: function (callDetails, input) {\n              if (!_disableFetchTracking) {\n                var fetchData_1 = callDetails.ctx().data;\n\n                if (fetchData_1) {\n                  // Replace the result with the new promise from this code\n                  callDetails.rslt = callDetails.rslt.then(function (response) {\n                    _reportFetchMetrics(callDetails, (response || {})[_DYN_STATUS\n                    /* @min:%2estatus */\n                    ], input, response, fetchData_1, function () {\n                      var ajaxResponse = {\n                        statusText: (response || {})[_DYN_STATUS_TEXT\n                        /* @min:%2estatusText */\n                        ],\n                        headerMap: null,\n                        correlationContext: _getFetchCorrelationContext(response)\n                      };\n\n                      if (_enableResponseHeaderTracking && response) {\n                        var responseHeaderMap_1 = {};\n                        response.headers.forEach(function (value, name) {\n                          if (_canIncludeHeaders(name)) {\n                            responseHeaderMap_1[name] = value;\n                          }\n                        });\n                        ajaxResponse[_DYN_HEADER_MAP\n                        /* @min:%2eheaderMap */\n                        ] = responseHeaderMap_1;\n                      }\n\n                      return ajaxResponse;\n                    });\n\n                    return response;\n                  })[\"catch\"](function (reason) {\n                    _reportFetchMetrics(callDetails, 0, input, null, fetchData_1, null, {\n                      error: reason.message || dumpObj(reason)\n                    });\n\n                    throw reason;\n                  });\n                }\n              }\n            },\n            // Create an error callback to report any hook errors\n            hkErr: _createErrorCallbackFunc(_self, 15\n            /* _eInternalMessageId.FailedMonitorAjaxOpen */\n            , \"Failed to monitor Window.fetch\" + ERROR_POSTFIX)\n          }, true, isWebWorker()));\n\n          _fetchInitialized = true;\n        } else if (isPolyfill) {\n          // If fetch is a polyfill we need to capture the request to ensure that we correctly track\n          // disabled request URLS (i.e. internal urls) to ensure we don't end up in a constant loop\n          // of reporting ourselves, for example React Native uses a polyfill for fetch\n          // Note: Polyfill implementations that don't support the \"poyyfill\" tag are not supported\n          // the workaround is to add a polyfill property to your fetch implementation before initializing\n          // App Insights\n          _addHook(InstrumentFunc(global, STR_FETCH, {\n            ns: _evtNamespace,\n            req: function (callDetails, input, init) {\n              // Just call so that we record any disabled URL\n              _isDisabledRequest(null, input, init);\n            }\n          }));\n        }\n\n        if (isPolyfill) {\n          // retag the instrumented fetch with the same polyfill settings this is mostly for testing\n          // But also supports multiple App Insights usages\n          global[STR_FETCH].polyfill = isPolyfill;\n        }\n      }\n\n      function _hookProto(target, funcName, callbacks) {\n        _addHook(InstrumentProto(target, funcName, callbacks));\n      }\n\n      function _instrumentXhr() {\n        if (_supportsAjaxMonitoring(_self, _ajaxDataId) && !_disableAjaxTracking && !_xhrInitialized) {\n          // Instrument open\n          _hookProto(XMLHttpRequest, \"open\", {\n            ns: _evtNamespace,\n            req: function (callDetails, method, url, async) {\n              if (!_disableAjaxTracking) {\n                var xhr = callDetails[_DYN_INST\n                /* @min:%2einst */\n                ];\n\n                var ajaxData = _getAjaxData(xhr, _ajaxDataId);\n\n                if (!_isDisabledRequest(xhr, url) && _isMonitoredXhrInstance(xhr, ajaxData, true)) {\n                  if (!ajaxData || !ajaxData.xhrMonitoringState[_DYN_OPEN_DONE\n                  /* @min:%2eopenDone */\n                  ]) {\n                    // Only create a single ajaxData (even when multiple AI instances are running)\n                    ajaxData = _openHandler(xhr, method, url, async);\n                  } // always attach to the on ready state change (required for handling multiple instances)\n\n\n                  _attachToOnReadyStateChange(xhr, ajaxData);\n                }\n              }\n            },\n            hkErr: _createErrorCallbackFunc(_self, 15\n            /* _eInternalMessageId.FailedMonitorAjaxOpen */\n            , ERROR_HEADER + \".open\" + ERROR_POSTFIX)\n          }); // Instrument send\n\n\n          _hookProto(XMLHttpRequest, \"send\", {\n            ns: _evtNamespace,\n            req: function (callDetails, context) {\n              if (!_disableAjaxTracking) {\n                var xhr = callDetails[_DYN_INST\n                /* @min:%2einst */\n                ];\n\n                var ajaxData = _getAjaxData(xhr, _ajaxDataId);\n\n                if (_isMonitoredXhrInstance(xhr, ajaxData) && !ajaxData.xhrMonitoringState[_DYN_SEND_DONE\n                /* @min:%2esendDone */\n                ]) {\n                  _createMarkId(\"xhr\", ajaxData);\n\n                  ajaxData[_DYN_REQUEST_SENT_TIME\n                  /* @min:%2erequestSentTime */\n                  ] = dateTimeUtilsNow();\n\n                  _self[_DYN_INCLUDE_CORRELATION_2\n                  /* @min:%2eincludeCorrelationHeaders */\n                  ](ajaxData, undefined, undefined, xhr);\n\n                  ajaxData.xhrMonitoringState[_DYN_SEND_DONE\n                  /* @min:%2esendDone */\n                  ] = true;\n                }\n              }\n            },\n            hkErr: _createErrorCallbackFunc(_self, 17\n            /* _eInternalMessageId.FailedMonitorAjaxSend */\n            , ERROR_HEADER + ERROR_POSTFIX)\n          }); // Instrument abort\n\n\n          _hookProto(XMLHttpRequest, \"abort\", {\n            ns: _evtNamespace,\n            req: function (callDetails) {\n              if (!_disableAjaxTracking) {\n                var xhr = callDetails[_DYN_INST\n                /* @min:%2einst */\n                ];\n\n                var ajaxData = _getAjaxData(xhr, _ajaxDataId);\n\n                if (_isMonitoredXhrInstance(xhr, ajaxData) && !ajaxData.xhrMonitoringState[_DYN_ABORT_DONE\n                /* @min:%2eabortDone */\n                ]) {\n                  ajaxData[_DYN_ABORTED\n                  /* @min:%2eaborted */\n                  ] = 1;\n                  ajaxData.xhrMonitoringState[_DYN_ABORT_DONE\n                  /* @min:%2eabortDone */\n                  ] = true;\n                }\n              }\n            },\n            hkErr: _createErrorCallbackFunc(_self, 13\n            /* _eInternalMessageId.FailedMonitorAjaxAbort */\n            , ERROR_HEADER + \".abort\" + ERROR_POSTFIX)\n          }); // Instrument setRequestHeader\n\n\n          _hookProto(XMLHttpRequest, \"setRequestHeader\", {\n            ns: _evtNamespace,\n            req: function (callDetails, header, value) {\n              if (!_disableAjaxTracking) {\n                var xhr = callDetails[_DYN_INST\n                /* @min:%2einst */\n                ];\n\n                var ajaxData = _getAjaxData(xhr, _ajaxDataId);\n\n                if (ajaxData && _isMonitoredXhrInstance(xhr, ajaxData)) {\n                  _addSharedXhrHeaders(xhr, header, value);\n\n                  if (_enableRequestHeaderTracking && _canIncludeHeaders(header)) {\n                    if (ajaxData) {\n                      ajaxData[_DYN_REQUEST_HEADERS\n                      /* @min:%2erequestHeaders */\n                      ][header] = value;\n                    }\n                  }\n                }\n              }\n            },\n            hkErr: _createErrorCallbackFunc(_self, 71\n            /* _eInternalMessageId.FailedMonitorAjaxSetRequestHeader */\n            , ERROR_HEADER + \".setRequestHeader\" + ERROR_POSTFIX)\n          });\n\n          _xhrInitialized = true;\n        }\n      }\n\n      function _isDisabledRequest(xhr, request, init) {\n        var isDisabled = false;\n\n        var theUrl = ((!isString(request) ? (request || {}).url || \"\" : request) || \"\")[_DYN_TO_LOWER_CASE\n        /* @min:%2etoLowerCase */\n        ](); // check excludeRequestFromAutoTrackingPatterns before stripping off any query string\n\n\n        arrForEach(_excludeRequestFromAutoTrackingPatterns, function (regex) {\n          var theRegex = regex;\n\n          if (isString(regex)) {\n            theRegex = new RegExp(regex);\n          }\n\n          if (!isDisabled) {\n            isDisabled = theRegex.test(theUrl);\n          }\n        }); // if request url matches with exclude regex pattern, return true and no need to check for headers\n\n        if (isDisabled) {\n          return isDisabled;\n        }\n\n        var idx = _indexOf(theUrl, \"?\");\n\n        var idx2 = _indexOf(theUrl, \"#\");\n\n        if (idx === -1 || idx2 !== -1 && idx2 < idx) {\n          idx = idx2;\n        }\n\n        if (idx !== -1) {\n          // Strip off any Query string\n          theUrl = theUrl.substring(0, idx);\n        } // check that this instance is not not used by ajax call performed inside client side monitoring to send data to collector\n\n\n        if (!isNullOrUndefined(xhr)) {\n          // Look on the XMLHttpRequest of the URL string value\n          isDisabled = xhr[DisabledPropertyName] === true || theUrl[DisabledPropertyName] === true;\n        } else if (!isNullOrUndefined(request)) {\n          // fetch\n          // Look for DisabledPropertyName in either Request or RequestInit\n          isDisabled = (typeof request === \"object\" ? request[DisabledPropertyName] === true : false) || (init ? init[DisabledPropertyName] === true : false);\n        } // Also add extra check just in case the XHR or fetch objects where not decorated with the DisableProperty due to sealing or freezing\n\n\n        if (!isDisabled && theUrl && isInternalApplicationInsightsEndpoint(theUrl)) {\n          isDisabled = true;\n        }\n\n        if (isDisabled) {\n          // Add the disabled url if not present\n          if (!_disabledUrls[theUrl]) {\n            _disabledUrls[theUrl] = 1;\n          }\n        } else {\n          // Check to see if the url is listed as disabled\n          if (_disabledUrls[theUrl]) {\n            isDisabled = true;\n          }\n        }\n\n        return isDisabled;\n      } /// <summary>Verifies that particular instance of XMLHttpRequest needs to be monitored</summary>\n      /// <param name=\"excludeAjaxDataValidation\">Optional parameter. True if ajaxData must be excluded from verification</param>\n      /// <returns type=\"bool\">True if instance needs to be monitored, otherwise false</returns>\n\n\n      function _isMonitoredXhrInstance(xhr, ajaxData, excludeAjaxDataValidation) {\n        var ajaxValidation = true;\n        var initialized = _xhrInitialized;\n\n        if (!isNullOrUndefined(xhr)) {\n          ajaxValidation = excludeAjaxDataValidation === true || !isNullOrUndefined(ajaxData);\n        } // checking to see that all interested functions on xhr were instrumented\n\n\n        return initialized // checking on ajaxData to see that it was not removed in user code\n        && ajaxValidation;\n      }\n\n      function _getDistributedTraceCtx() {\n        var distributedTraceCtx = null;\n\n        if (_self[_DYN_CORE\n        /* @min:%2ecore */\n        ] && _self[_DYN_CORE\n        /* @min:%2ecore */\n        ].getTraceCtx) {\n          distributedTraceCtx = _self[_DYN_CORE\n          /* @min:%2ecore */\n          ].getTraceCtx(false);\n        } // Fall back\n\n\n        if (!distributedTraceCtx && _context && _context.telemetryTrace) {\n          distributedTraceCtx = createDistributedTraceContextFromTrace(_context.telemetryTrace);\n        }\n\n        return distributedTraceCtx;\n      }\n\n      function _openHandler(xhr, method, url, async) {\n        var _a;\n\n        var distributedTraceCtx = _getDistributedTraceCtx();\n\n        var traceID = distributedTraceCtx && distributedTraceCtx[_DYN_GET_TRACE_ID\n        /* @min:%2egetTraceId */\n        ]() || generateW3CId();\n        var spanID = generateW3CId().substr(0, 16);\n        var xhrRequestData = xhr[AJAX_DATA_CONTAINER] = xhr[AJAX_DATA_CONTAINER] || {\n          xh: [],\n          i: {}\n        };\n        var ajaxDataCntr = xhrRequestData.i = xhrRequestData.i || {};\n        var ajaxData = ajaxDataCntr[_ajaxDataId] = ajaxDataCntr[_ajaxDataId] || new ajaxRecord(traceID, spanID, _self[strDiagLog](), (_a = _self.core) === null || _a === void 0 ? void 0 : _a.getTraceCtx());\n        ajaxData[_DYN_TRACE_FLAGS\n        /* @min:%2etraceFlags */\n        ] = distributedTraceCtx && distributedTraceCtx[_DYN_GET_TRACE_FLAGS\n        /* @min:%2egetTraceFlags */\n        ]();\n        ajaxData[_DYN_METHOD\n        /* @min:%2emethod */\n        ] = method;\n        ajaxData[_DYN_REQUEST_URL\n        /* @min:%2erequestUrl */\n        ] = url;\n        ajaxData.xhrMonitoringState[_DYN_OPEN_DONE\n        /* @min:%2eopenDone */\n        ] = true;\n        ajaxData[_DYN_REQUEST_HEADERS\n        /* @min:%2erequestHeaders */\n        ] = {};\n        ajaxData.async = async;\n        ajaxData[_DYN_ERROR_STATUS_TEXT\n        /* @min:%2eerrorStatusText */\n        ] = _enableAjaxErrorStatusText;\n        return ajaxData;\n      }\n\n      function _attachToOnReadyStateChange(xhr, ajaxData) {\n        ajaxData.xhrMonitoringState[_DYN_STATE_CHANGE_ATTACHE14\n        /* @min:%2estateChangeAttached */\n        ] = eventOn(xhr, \"readystatechange\", function () {\n          try {\n            if (xhr && xhr.readyState === 4 && _isMonitoredXhrInstance(xhr, ajaxData)) {\n              _onAjaxComplete(xhr);\n            }\n          } catch (e) {\n            var exceptionText = dumpObj(e); // ignore messages with c00c023f, as this a known IE9 XHR abort issue\n\n            if (!exceptionText || _indexOf(exceptionText[_DYN_TO_LOWER_CASE\n            /* @min:%2etoLowerCase */\n            ](), \"c00c023f\") === -1) {\n              _throwInternalCritical(_self, 16\n              /* _eInternalMessageId.FailedMonitorAjaxRSC */\n              , ERROR_HEADER + \" 'readystatechange' event handler\" + ERROR_POSTFIX, {\n                ajaxDiagnosticsMessage: _getFailedAjaxDiagnosticsMessage(xhr, _ajaxDataId),\n                exception: exceptionText\n              });\n            }\n          }\n        }, _evtNamespace);\n      }\n\n      function _getResponseText(xhr) {\n        try {\n          var responseType = xhr.responseType;\n\n          if (responseType === \"\" || responseType === \"text\") {\n            // As per the specification responseText is only valid if the type is an empty string or \"text\"\n            return xhr[_DYN_RESPONSE_TEXT\n            /* @min:%2eresponseText */\n            ];\n          }\n        } catch (e) {// This shouldn't happen because of the above check -- but just in case, so just ignore\n        }\n\n        return null;\n      }\n\n      function _onAjaxComplete(xhr) {\n        var ajaxData = _getAjaxData(xhr, _ajaxDataId);\n\n        ajaxData[_DYN_RESPONSE_FINISHED_TI15\n        /* @min:%2eresponseFinishedTime */\n        ] = dateTimeUtilsNow();\n        ajaxData[_DYN_STATUS\n        /* @min:%2estatus */\n        ] = xhr[_DYN_STATUS\n        /* @min:%2estatus */\n        ];\n\n        function _reportXhrError(e, failedProps) {\n          var errorProps = failedProps || {};\n          errorProps[\"ajaxDiagnosticsMessage\"] = _getFailedAjaxDiagnosticsMessage(xhr, _ajaxDataId);\n\n          if (e) {\n            errorProps[\"exception\"] = dumpObj(e);\n          }\n\n          _throwInternalWarning(_self, 14\n          /* _eInternalMessageId.FailedMonitorAjaxDur */\n          , FAILED_TO_CALCULATE_DURATION_ERROR + \"ajax call\" + ERROR_NOT_SENT, errorProps);\n        }\n\n        _findPerfResourceEntry(\"xmlhttprequest\", ajaxData, function () {\n          try {\n            var dependency = ajaxData[_DYN__CREATE_TRACK_ITEM\n            /* @min:%2eCreateTrackItem */\n            ](\"Ajax\", _enableRequestHeaderTracking, function () {\n              var ajaxResponse = {\n                statusText: xhr[_DYN_STATUS_TEXT\n                /* @min:%2estatusText */\n                ],\n                headerMap: null,\n                correlationContext: _getAjaxCorrelationContext(xhr),\n                type: xhr.responseType,\n                responseText: _getResponseText(xhr),\n                response: xhr[_DYN_RESPONSE\n                /* @min:%2eresponse */\n                ]\n              };\n\n              if (_enableResponseHeaderTracking) {\n                var headers = xhr[_DYN_GET_ALL_RESPONSE_HEA16\n                /* @min:%2egetAllResponseHeaders */\n                ]();\n\n                if (headers) {\n                  // xhr.getAllResponseHeaders() method returns all the response headers, separated by CRLF, as a string or null\n                  // the regex converts the header string into an array of individual headers\n                  var arr = strTrim(headers).split(/[\\r\\n]+/);\n                  var responseHeaderMap_2 = {};\n                  arrForEach(arr, function (line) {\n                    var parts = line.split(\": \");\n                    var header = parts.shift();\n                    var value = parts.join(\": \");\n\n                    if (_canIncludeHeaders(header)) {\n                      responseHeaderMap_2[header] = value;\n                    }\n                  });\n                  ajaxResponse[_DYN_HEADER_MAP\n                  /* @min:%2eheaderMap */\n                  ] = responseHeaderMap_2;\n                }\n              }\n\n              return ajaxResponse;\n            });\n\n            var properties = void 0;\n\n            try {\n              if (!!_addRequestContext) {\n                properties = _addRequestContext({\n                  status: xhr[_DYN_STATUS\n                  /* @min:%2estatus */\n                  ],\n                  xhr: xhr\n                });\n              }\n            } catch (e) {\n              _throwInternalWarning(_self, 104\n              /* _eInternalMessageId.FailedAddingCustomDefinedRequestContext */\n              , CUSTOM_REQUEST_CONTEXT_ERROR);\n            }\n\n            if (dependency) {\n              if (properties !== undefined) {\n                dependency[STR_PROPERTIES\n                /* @min:%2eproperties */\n                ] = __assign(__assign({}, dependency.properties), properties);\n              }\n\n              var sysProperties = ajaxData[_DYN_GET_PART_APROPS\n              /* @min:%2egetPartAProps */\n              ]();\n\n              _reportDependencyInternal(_dependencyInitializers, _self[_DYN_CORE\n              /* @min:%2ecore */\n              ], ajaxData, dependency, null, sysProperties);\n            } else {\n              _reportXhrError(null, {\n                requestSentTime: ajaxData[_DYN_REQUEST_SENT_TIME\n                /* @min:%2erequestSentTime */\n                ],\n                responseFinishedTime: ajaxData[_DYN_RESPONSE_FINISHED_TI15\n                /* @min:%2eresponseFinishedTime */\n                ]\n              });\n            }\n          } finally {\n            // cleanup telemetry data\n            try {\n              var xhrRequestData = xhr[AJAX_DATA_CONTAINER] || {\n                i: {}\n              };\n              var ajaxDataCntr = xhrRequestData.i || {};\n\n              if (ajaxDataCntr[_ajaxDataId]) {\n                ajaxDataCntr[_ajaxDataId] = null;\n              }\n            } catch (e) {// May throw in environments that prevent extension or freeze xhr\n            }\n          }\n        }, function (e) {\n          _reportXhrError(e, null);\n        });\n      }\n\n      function _getAjaxCorrelationContext(xhr) {\n        try {\n          var responseHeadersString = xhr[_DYN_GET_ALL_RESPONSE_HEA16\n          /* @min:%2egetAllResponseHeaders */\n          ]();\n\n          if (responseHeadersString !== null) {\n            var index = _indexOf(responseHeadersString[_DYN_TO_LOWER_CASE\n            /* @min:%2etoLowerCase */\n            ](), RequestHeaders[8\n            /* eRequestHeaders.requestContextHeaderLowerCase */\n            ]);\n\n            if (index !== -1) {\n              var responseHeader = xhr.getResponseHeader(RequestHeaders[0\n              /* eRequestHeaders.requestContextHeader */\n              ]);\n              return CorrelationIdHelper[_DYN_GET_CORRELATION_CONT17\n              /* @min:%2egetCorrelationContext */\n              ](responseHeader);\n            }\n          }\n        } catch (e) {\n          _throwInternalWarning(_self, 18\n          /* _eInternalMessageId.FailedMonitorAjaxGetCorrelationHeader */\n          , CORRELATION_HEADER_ERROR, {\n            ajaxDiagnosticsMessage: _getFailedAjaxDiagnosticsMessage(xhr, _ajaxDataId),\n            exception: dumpObj(e)\n          });\n        }\n      }\n\n      function _createMarkId(type, ajaxData) {\n        if (ajaxData[_DYN_REQUEST_URL\n        /* @min:%2erequestUrl */\n        ] && _markPrefix && _enableAjaxPerfTracking) {\n          var performance_1 = getPerformance();\n\n          if (performance_1 && isFunction(performance_1.mark)) {\n            _markCount++;\n            var markId = _markPrefix + type + \"#\" + _markCount;\n            performance_1.mark(markId);\n            var entries = performance_1.getEntriesByName(markId);\n\n            if (entries && entries[_DYN_LENGTH\n            /* @min:%2elength */\n            ] === 1) {\n              ajaxData[_DYN_PERF_MARK\n              /* @min:%2eperfMark */\n              ] = entries[0];\n            }\n          }\n        }\n      }\n\n      function _findPerfResourceEntry(initiatorType, ajaxData, trackCallback, reportError) {\n        var perfMark = ajaxData[_DYN_PERF_MARK\n        /* @min:%2eperfMark */\n        ];\n        var performance = getPerformance();\n        var maxAttempts = _config.maxAjaxPerfLookupAttempts;\n        var retryDelay = _config[_DYN_AJAX_PERF_LOOKUP_DEL18\n        /* @min:%2eajaxPerfLookupDelay */\n        ];\n        var requestUrl = ajaxData[_DYN_REQUEST_URL\n        /* @min:%2erequestUrl */\n        ];\n        var attempt = 0;\n\n        (function locateResourceTiming() {\n          try {\n            if (performance && perfMark) {\n              attempt++;\n              var perfTiming = null;\n              var entries = performance.getEntries();\n\n              for (var lp = entries[_DYN_LENGTH\n              /* @min:%2elength */\n              ] - 1; lp >= 0; lp--) {\n                var entry = entries[lp];\n\n                if (entry) {\n                  if (entry.entryType === \"resource\") {\n                    if (entry.initiatorType === initiatorType && (_indexOf(entry[_DYN_NAME\n                    /* @min:%2ename */\n                    ], requestUrl) !== -1 || _indexOf(requestUrl, entry[_DYN_NAME\n                    /* @min:%2ename */\n                    ]) !== -1)) {\n                      perfTiming = entry;\n                    }\n                  } else if (entry.entryType === \"mark\" && entry[_DYN_NAME\n                  /* @min:%2ename */\n                  ] === perfMark[_DYN_NAME\n                  /* @min:%2ename */\n                  ]) {\n                    // We hit the start event\n                    ajaxData[_DYN_PERF_TIMING\n                    /* @min:%2eperfTiming */\n                    ] = perfTiming;\n                    break;\n                  }\n\n                  if (entry[_DYN_START_TIME\n                  /* @min:%2estartTime */\n                  ] < perfMark[_DYN_START_TIME\n                  /* @min:%2estartTime */\n                  ] - 1000) {\n                    // Fallback to try and reduce the time spent looking for the perf entry\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (!perfMark || // - we don't have a perfMark or\n            ajaxData[_DYN_PERF_TIMING\n            /* @min:%2eperfTiming */\n            ] || // - we have not found the perf entry or\n            attempt >= maxAttempts || // - we have tried too many attempts or\n            ajaxData.async === false) {\n              // - this is a sync request\n              if (perfMark && isFunction(performance.clearMarks)) {\n                // Remove the mark so we don't fill up the performance resources too much\n                performance.clearMarks(perfMark[_DYN_NAME\n                /* @min:%2ename */\n                ]);\n              }\n\n              ajaxData.perfAttempts = attempt; // just continue and report the track event\n\n              trackCallback();\n            } else {\n              // We need to wait for the browser to populate the window.performance entry\n              // This needs to be at least 1ms as waiting <= 1 (on firefox) is not enough time for fetch or xhr,\n              // this is a scheduling issue for the browser implementation\n              setTimeout(locateResourceTiming, retryDelay);\n            }\n          } catch (e) {\n            reportError(e);\n          }\n        })();\n      }\n\n      function _createFetchRecord(input, init) {\n        var _a;\n\n        var distributedTraceCtx = _getDistributedTraceCtx();\n\n        var traceID = distributedTraceCtx && distributedTraceCtx[_DYN_GET_TRACE_ID\n        /* @min:%2egetTraceId */\n        ]() || generateW3CId();\n        var spanID = generateW3CId().substr(0, 16);\n        var ajaxData = new ajaxRecord(traceID, spanID, _self[strDiagLog](), (_a = _self.core) === null || _a === void 0 ? void 0 : _a.getTraceCtx());\n        ajaxData[_DYN_TRACE_FLAGS\n        /* @min:%2etraceFlags */\n        ] = distributedTraceCtx && distributedTraceCtx[_DYN_GET_TRACE_FLAGS\n        /* @min:%2egetTraceFlags */\n        ]();\n        ajaxData[_DYN_REQUEST_SENT_TIME\n        /* @min:%2erequestSentTime */\n        ] = dateTimeUtilsNow();\n        ajaxData[_DYN_ERROR_STATUS_TEXT\n        /* @min:%2eerrorStatusText */\n        ] = _enableAjaxErrorStatusText;\n\n        if (input instanceof Request) {\n          ajaxData[_DYN_REQUEST_URL\n          /* @min:%2erequestUrl */\n          ] = input ? input.url : \"\";\n        } else {\n          ajaxData[_DYN_REQUEST_URL\n          /* @min:%2erequestUrl */\n          ] = input;\n        }\n\n        var method = \"GET\";\n\n        if (init && init[_DYN_METHOD\n        /* @min:%2emethod */\n        ]) {\n          method = init[_DYN_METHOD\n          /* @min:%2emethod */\n          ];\n        } else if (input && input instanceof Request) {\n          method = input[_DYN_METHOD\n          /* @min:%2emethod */\n          ];\n        }\n\n        ajaxData[_DYN_METHOD\n        /* @min:%2emethod */\n        ] = method;\n        var requestHeaders = {};\n\n        if (_enableRequestHeaderTracking) {\n          var headers = new Headers((init ? init[_DYN_HEADERS\n          /* @min:%2eheaders */\n          ] : 0) || (input instanceof Request ? input[_DYN_HEADERS\n          /* @min:%2eheaders */\n          ] || {} : {}));\n          headers.forEach(function (value, key) {\n            if (_canIncludeHeaders(key)) {\n              requestHeaders[key] = value;\n            }\n          });\n        }\n\n        ajaxData[_DYN_REQUEST_HEADERS\n        /* @min:%2erequestHeaders */\n        ] = requestHeaders;\n\n        _createMarkId(STR_FETCH, ajaxData);\n\n        return ajaxData;\n      }\n\n      function _getFailedFetchDiagnosticsMessage(input) {\n        var result = \"\";\n\n        try {\n          if (!isNullOrUndefined(input)) {\n            if (isString(input)) {\n              result += \"(url: '\".concat(input, \"')\");\n            } else {\n              result += \"(url: '\".concat(input.url, \"')\");\n            }\n          }\n        } catch (e) {\n          _throwInternalCritical(_self, 15\n          /* _eInternalMessageId.FailedMonitorAjaxOpen */\n          , \"Failed to grab failed fetch diagnostics message\", {\n            exception: dumpObj(e)\n          });\n        }\n\n        return result;\n      }\n\n      function _reportFetchMetrics(callDetails, status, input, response, ajaxData, getResponse, properties) {\n        if (!ajaxData) {\n          return;\n        }\n\n        function _reportFetchError(msgId, e, failedProps) {\n          var errorProps = failedProps || {};\n          errorProps[\"fetchDiagnosticsMessage\"] = _getFailedFetchDiagnosticsMessage(input);\n\n          if (e) {\n            errorProps[\"exception\"] = dumpObj(e);\n          }\n\n          _throwInternalWarning(_self, msgId, FAILED_TO_CALCULATE_DURATION_ERROR + \"fetch call\" + ERROR_NOT_SENT, errorProps);\n        }\n\n        ajaxData[_DYN_RESPONSE_FINISHED_TI15\n        /* @min:%2eresponseFinishedTime */\n        ] = dateTimeUtilsNow();\n        ajaxData[_DYN_STATUS\n        /* @min:%2estatus */\n        ] = status;\n\n        _findPerfResourceEntry(STR_FETCH, ajaxData, function () {\n          var dependency = ajaxData[_DYN__CREATE_TRACK_ITEM\n          /* @min:%2eCreateTrackItem */\n          ](\"Fetch\", _enableRequestHeaderTracking, getResponse);\n\n          var properties;\n\n          try {\n            if (!!_addRequestContext) {\n              properties = _addRequestContext({\n                status: status,\n                request: input,\n                response: response\n              });\n            }\n          } catch (e) {\n            _throwInternalWarning(_self, 104\n            /* _eInternalMessageId.FailedAddingCustomDefinedRequestContext */\n            , CUSTOM_REQUEST_CONTEXT_ERROR);\n          }\n\n          if (dependency) {\n            if (properties !== undefined) {\n              dependency[STR_PROPERTIES\n              /* @min:%2eproperties */\n              ] = __assign(__assign({}, dependency.properties), properties);\n            }\n\n            var sysProperties = ajaxData[_DYN_GET_PART_APROPS\n            /* @min:%2egetPartAProps */\n            ]();\n\n            _reportDependencyInternal(_dependencyInitializers, _self[_DYN_CORE\n            /* @min:%2ecore */\n            ], ajaxData, dependency, null, sysProperties);\n          } else {\n            _reportFetchError(14\n            /* _eInternalMessageId.FailedMonitorAjaxDur */\n            , null, {\n              requestSentTime: ajaxData[_DYN_REQUEST_SENT_TIME\n              /* @min:%2erequestSentTime */\n              ],\n              responseFinishedTime: ajaxData[_DYN_RESPONSE_FINISHED_TI15\n              /* @min:%2eresponseFinishedTime */\n              ]\n            });\n          }\n        }, function (e) {\n          _reportFetchError(18\n          /* _eInternalMessageId.FailedMonitorAjaxGetCorrelationHeader */\n          , e, null);\n        });\n      }\n\n      function _getFetchCorrelationContext(response) {\n        if (response && response[_DYN_HEADERS\n        /* @min:%2eheaders */\n        ]) {\n          try {\n            var responseHeader = response[_DYN_HEADERS\n            /* @min:%2eheaders */\n            ].get(RequestHeaders[0\n            /* eRequestHeaders.requestContextHeader */\n            ]);\n\n            return CorrelationIdHelper[_DYN_GET_CORRELATION_CONT17\n            /* @min:%2egetCorrelationContext */\n            ](responseHeader);\n          } catch (e) {\n            _throwInternalWarning(_self, 18\n            /* _eInternalMessageId.FailedMonitorAjaxGetCorrelationHeader */\n            , CORRELATION_HEADER_ERROR, {\n              fetchDiagnosticsMessage: _getFailedFetchDiagnosticsMessage(response),\n              exception: dumpObj(e)\n            });\n          }\n        }\n      }\n\n      function _reportDependencyInternal(initializers, core, ajaxData, dependency, properties, systemProperties) {\n        var result = true;\n        var initializersCount = initializers[_DYN_LENGTH\n        /* @min:%2elength */\n        ];\n\n        if (initializersCount > 0) {\n          var details = {\n            item: dependency,\n            properties: properties,\n            sysProperties: systemProperties,\n            context: ajaxData ? ajaxData[_DYN_CONTEXT\n            /* @min:%2econtext */\n            ] : null,\n            aborted: ajaxData ? !!ajaxData[_DYN_ABORTED\n            /* @min:%2eaborted */\n            ] : false\n          };\n          result = _processDependencyContainer(core, initializers, details, \"initializer\");\n        }\n\n        if (result) {\n          _self[_DYN_TRACK_DEPENDENCY_DAT4\n          /* @min:%2etrackDependencyDataInternal */\n          ](dependency, properties, systemProperties);\n        }\n      }\n    });\n    return _this;\n  } // Removed Stub for AjaxMonitor.prototype.initialize.\n\n\n  AjaxMonitor.prototype.processTelemetry = function (item, itemCtx) {\n    this.processNext(item, itemCtx);\n  }; // Removed Stub for AjaxMonitor.prototype.trackDependencyData.\n  // Removed Stub for AjaxMonitor.prototype.includeCorrelationHeaders.\n  // Removed Stub for AjaxMonitor.prototype.addDependencyListener.\n\n  /**\r\n   * Add an dependency telemetry initializer callback function to allow populating additional properties or drop the request.\r\n   * It is called after the dependency call has completed and any available performance details are available. A dependency\r\n   * initializer is similar to the TelemetryInitializer function but it allows you to block the reporting of the dependency\r\n   * request so that it doesn't count against the `maxAjaxCallsPerView`.\r\n   * @param dependencyInitializer - The Dependency Telemetry Initializer function\r\n   * @returns - A IDependencyInitializerHandler to enable the initializer to be removed\r\n   */\n\n\n  AjaxMonitor.prototype.addDependencyInitializer = function (dependencyInitializer) {\n    return null;\n  }; // Removed Stub for AjaxMonitor.prototype.trackDependencyDataInternal.\n\n\n  AjaxMonitor.identifier = \"AjaxDependencyPlugin\";\n  AjaxMonitor.getDefaultConfig = _getDefaultConfig;\n  AjaxMonitor.getEmptyConfig = _getEmptyConfig;\n  return AjaxMonitor;\n}(BaseTelemetryPlugin);\n\nexport { AjaxMonitor }; //# sourceMappingURL=ajax.js.map","map":null,"metadata":{},"sourceType":"module"}