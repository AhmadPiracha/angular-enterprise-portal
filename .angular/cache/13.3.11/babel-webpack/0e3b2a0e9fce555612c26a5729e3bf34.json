{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.18\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\"use strict\";\n\nimport { _DYN_CALL, _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_INITIALIZE, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_SPAN_ID, _DYN_TEARDOWN, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\nimport { createElmNodeData } from \"./DataCacheHelper\";\nimport { arrForEach, isFunction } from \"./HelperFuncs\";\nimport { STR_CORE, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\nimport { isValidSpanId, isValidTraceId } from \"./W3cTraceParent\";\nvar pluginStateData = createElmNodeData(\"plugin\");\nexport function _getPluginState(plugin) {\n  return pluginStateData.get(plugin, \"state\", {}, true);\n}\n/**\r\n * Initialize the queue of plugins\r\n * @param plugins - The array of plugins to initialize and setting of the next plugin\r\n * @param config The current config for the instance\r\n * @param core THe current core instance\r\n * @param extensions The extensions\r\n */\n\nexport function initializePlugins(processContext, extensions) {\n  // Set the next plugin and identified the uninitialized plugins\n  var initPlugins = [];\n  var lastPlugin = null;\n\n  var proxy = processContext[_DYN_GET_NEXT\n  /* @min:%2egetNext */\n  ]();\n\n  var pluginState;\n\n  while (proxy) {\n    var thePlugin = proxy[_DYN_GET_PLUGIN\n    /* @min:%2egetPlugin */\n    ]();\n\n    if (thePlugin) {\n      if (lastPlugin && isFunction(lastPlugin[_DYN_SET_NEXT_PLUGIN\n      /* @min:%2esetNextPlugin */\n      ]) && isFunction(thePlugin[STR_PROCESS_TELEMETRY\n      /* @min:%2eprocessTelemetry */\n      ])) {\n        // Set this plugin as the next for the previous one\n        lastPlugin[_DYN_SET_NEXT_PLUGIN\n        /* @min:%2esetNextPlugin */\n        ](thePlugin);\n      }\n\n      var isInitialized = false;\n\n      if (isFunction(thePlugin[_DYN_IS_INITIALIZED\n      /* @min:%2eisInitialized */\n      ])) {\n        isInitialized = thePlugin[_DYN_IS_INITIALIZED\n        /* @min:%2eisInitialized */\n        ]();\n      } else {\n        pluginState = _getPluginState(thePlugin);\n        isInitialized = pluginState[_DYN_IS_INITIALIZED\n        /* @min:%2eisInitialized */\n        ];\n      }\n\n      if (!isInitialized) {\n        initPlugins[_DYN_PUSH\n        /* @min:%2epush */\n        ](thePlugin);\n      }\n\n      lastPlugin = thePlugin;\n      proxy = proxy[_DYN_GET_NEXT\n      /* @min:%2egetNext */\n      ]();\n    }\n  } // Now initialize the plugins\n\n\n  arrForEach(initPlugins, function (thePlugin) {\n    var core = processContext[STR_CORE]();\n\n    thePlugin[_DYN_INITIALIZE\n    /* @min:%2einitialize */\n    ](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT\n    /* @min:%2egetNext */\n    ]());\n\n    pluginState = _getPluginState(thePlugin); // Only add the core to the state if the plugin didn't set it (doesn't extent from BaseTelemetryPlugin)\n\n    if (!thePlugin[STR_CORE] && !pluginState[STR_CORE]) {\n      pluginState[STR_CORE] = core;\n    }\n\n    pluginState[_DYN_IS_INITIALIZED\n    /* @min:%2eisInitialized */\n    ] = true;\n    delete pluginState[_DYN_TEARDOWN\n    /* @min:%2eteardown */\n    ];\n  });\n}\nexport function sortPlugins(plugins) {\n  // Sort by priority\n  return plugins.sort(function (extA, extB) {\n    var result = 0;\n\n    if (extB) {\n      var bHasProcess = isFunction(extB[STR_PROCESS_TELEMETRY]);\n\n      if (isFunction(extA[STR_PROCESS_TELEMETRY])) {\n        result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;\n      } else if (bHasProcess) {\n        result = -1;\n      }\n    } else {\n      result = extA ? 1 : -1;\n    }\n\n    return result;\n  }); // sort complete\n}\n/**\r\n * Teardown / Unload helper to perform teardown/unloading operations for the provided components synchronously or asynchronously, this will call any\r\n * _doTeardown() or _doUnload() functions on the provided components to allow them to finish removal.\r\n * @param components - The components you want to unload\r\n * @param unloadCtx - This is the context that should be used during unloading.\r\n * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n * @param asyncCallback - An optional callback that the plugin must call if it returns true to inform the caller that it has completed any async unload/teardown operations.\r\n * @returns boolean - true if the plugin has or will call asyncCallback, this allows the plugin to perform any asynchronous operations.\r\n */\n\nexport function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {\n  var idx = 0;\n\n  function _doUnload() {\n    while (idx < components[_DYN_LENGTH\n    /* @min:%2elength */\n    ]) {\n      var component = components[idx++];\n\n      if (component) {\n        var func = component._doUnload || component[_DYN__DO_TEARDOWN\n        /* @min:%2e_doTeardown */\n        ];\n\n        if (isFunction(func)) {\n          if (func[_DYN_CALL\n          /* @min:%2ecall */\n          ](component, unloadCtx, unloadState, _doUnload) === true) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  return _doUnload();\n}\n/**\r\n * Creates a IDistributedTraceContext which optionally also \"sets\" the value on a parent\r\n * @param parentCtx - An optional parent distributed trace instance\r\n * @returns A new IDistributedTraceContext instance that uses an internal temporary object\r\n */\n\nexport function createDistributedTraceContext(parentCtx) {\n  var trace = {};\n  return {\n    getName: function () {\n      return trace[_DYN_NAME\n      /* @min:%2ename */\n      ];\n    },\n    setName: function (newValue) {\n      parentCtx && parentCtx.setName(newValue);\n      trace[_DYN_NAME\n      /* @min:%2ename */\n      ] = newValue;\n    },\n    getTraceId: function () {\n      return trace[_DYN_TRACE_ID\n      /* @min:%2etraceId */\n      ];\n    },\n    setTraceId: function (newValue) {\n      parentCtx && parentCtx.setTraceId(newValue);\n\n      if (isValidTraceId(newValue)) {\n        trace[_DYN_TRACE_ID\n        /* @min:%2etraceId */\n        ] = newValue;\n      }\n    },\n    getSpanId: function () {\n      return trace[_DYN_SPAN_ID\n      /* @min:%2espanId */\n      ];\n    },\n    setSpanId: function (newValue) {\n      parentCtx && parentCtx.setSpanId(newValue);\n\n      if (isValidSpanId(newValue)) {\n        trace[_DYN_SPAN_ID\n        /* @min:%2espanId */\n        ] = newValue;\n      }\n    },\n    getTraceFlags: function () {\n      return trace[_DYN_TRACE_FLAGS\n      /* @min:%2etraceFlags */\n      ];\n    },\n    setTraceFlags: function (newTraceFlags) {\n      parentCtx && parentCtx.setTraceFlags(newTraceFlags);\n      trace[_DYN_TRACE_FLAGS\n      /* @min:%2etraceFlags */\n      ] = newTraceFlags;\n    }\n  };\n} //# sourceMappingURL=TelemetryHelpers.js.map","map":null,"metadata":{},"sourceType":"module"}