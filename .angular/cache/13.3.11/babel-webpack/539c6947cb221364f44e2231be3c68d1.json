{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Channel, 2.8.18\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nvar _a;\n\nimport { __assignFn as __assign, __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { BreezeChannelIdentifier, DEFAULT_BREEZE_ENDPOINT, DEFAULT_BREEZE_PATH, DisabledPropertyName, Event, Exception, Metric, PageView, PageViewPerformance, ProcessLegacy, RemoteDependencyData, RequestHeaders, SampleRate, Trace, isInternalApplicationInsightsEndpoint, utlCanUseSessionStorage, utlSetStoragePrefix } from \"@microsoft/applicationinsights-common\";\nimport { BaseTelemetryPlugin, _throwInternal, _warnToConsole, arrForEach, arrIndexOf, createUniqueNamespace, dateNow, dumpObj, getExceptionName, getIEVersion, getJSON, getNavigator, getWindow, isArray, isBeaconsSupported, isFetchSupported, isNullOrUndefined, isXhrSupported, mergeEvtNamespace, objForEachKey, objKeys, useXDomainRequest } from \"@microsoft/applicationinsights-core-js\";\nimport { DependencyEnvelopeCreator, EventEnvelopeCreator, ExceptionEnvelopeCreator, MetricEnvelopeCreator, PageViewEnvelopeCreator, PageViewPerformanceEnvelopeCreator, TraceEnvelopeCreator } from \"./EnvelopeCreator\";\nimport { createOfflineListener } from \"./Offline\";\nimport { ArraySendBuffer, SessionStorageSendBuffer } from \"./SendBuffer\";\nimport { Serializer } from \"./Serializer\";\nimport { Sample } from \"./TelemetryProcessors/Sample\";\nimport { _DYN_BASE_TYPE, _DYN_BATCH_PAYLOADS, _DYN_BUFFER_OVERRIDE, _DYN_CLEAR, _DYN_CLEAR_SENT, _DYN_CONVERT_UNDEFINED, _DYN_COUNT, _DYN_CUSTOM_HEADERS, _DYN_DIAG_LOG, _DYN_DISABLE_INSTRUMENTAT7, _DYN_DISABLE_TELEMETRY, _DYN_DISABLE_XHR, _DYN_EMIT_LINE_DELIMITED_0, _DYN_ENABLE_SESSION_STORA4, _DYN_ENDPOINT_URL, _DYN_ENQUEUE, _DYN_EVENTS_LIMIT_IN_MEM, _DYN_EVENTS_SEND_REQUEST, _DYN_INSTRUMENTATION_KEY, _DYN_IS_BEACON_API_DISABL3, _DYN_IS_ONLINE, _DYN_IS_RETRY_DISABLED, _DYN_ITEMS_ACCEPTED, _DYN_ITEMS_RECEIVED, _DYN_LENGTH, _DYN_MARK_AS_SENT, _DYN_MAX_BATCH_INTERVAL, _DYN_MAX_BATCH_SIZE_IN_BY1, _DYN_NAME_PREFIX, _DYN_ONUNLOAD_DISABLE_BEA2, _DYN_ONUNLOAD_DISABLE_FET5, _DYN_PUSH, _DYN_SAMPLE_RATE, _DYN_SAMPLING_PERCENTAGE, _DYN_SET_REQUEST_HEADER, _DYN_TAGS, _DYN_TRIGGER_SEND, _DYN__BUFFER, _DYN__ON_ERROR, _DYN__ON_PARTIAL_SUCCESS, _DYN__ON_SUCCESS, _DYN__SENDER, _DYN__SENDER_CONFIG, _DYN__XHR_READY_STATE_CHA6 } from \"./__DynamicConstants\";\nvar FetchSyncRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)\n\nfunction _getResponseText(xhr) {\n  try {\n    return xhr.responseText;\n  } catch (e) {// Best effort, as XHR may throw while XDR wont so just ignore\n  }\n\n  return null;\n}\n\nfunction _getDefaultAppInsightsChannelConfig() {\n  var _a;\n\n  var defaultValue;\n  var defaultCustomHeaders; // set default values\n\n  return _a = {\n    endpointUrl: function () {\n      return DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH;\n    }\n  }, _a[_DYN_EMIT_LINE_DELIMITED_0\n  /* @min:emitLineDelimitedJson */\n  ] = function () {\n    return false;\n  }, _a[_DYN_MAX_BATCH_INTERVAL\n  /* @min:maxBatchInterval */\n  ] = function () {\n    return 15000;\n  }, _a[_DYN_MAX_BATCH_SIZE_IN_BY1\n  /* @min:maxBatchSizeInBytes */\n  ] = function () {\n    return 102400;\n  }, _a[_DYN_DISABLE_TELEMETRY\n  /* @min:disableTelemetry */\n  ] = function () {\n    return false;\n  }, _a[_DYN_ENABLE_SESSION_STORA4\n  /* @min:enableSessionStorageBuffer */\n  ] = function () {\n    return true;\n  }, _a[_DYN_BUFFER_OVERRIDE\n  /* @min:bufferOverride */\n  ] = function () {\n    return false;\n  }, _a[_DYN_IS_RETRY_DISABLED\n  /* @min:isRetryDisabled */\n  ] = function () {\n    return false;\n  }, _a[_DYN_IS_BEACON_API_DISABL3\n  /* @min:isBeaconApiDisabled */\n  ] = function () {\n    return true;\n  }, _a[_DYN_DISABLE_XHR\n  /* @min:disableXhr */\n  ] = function () {\n    return false;\n  }, _a[_DYN_ONUNLOAD_DISABLE_FET5\n  /* @min:onunloadDisableFetch */\n  ] = function () {\n    return false;\n  }, _a[_DYN_ONUNLOAD_DISABLE_BEA2\n  /* @min:onunloadDisableBeacon */\n  ] = function () {\n    return false;\n  }, _a[_DYN_INSTRUMENTATION_KEY\n  /* @min:instrumentationKey */\n  ] = function () {\n    return defaultValue;\n  }, _a[_DYN_NAME_PREFIX\n  /* @min:namePrefix */\n  ] = function () {\n    return defaultValue;\n  }, _a[_DYN_SAMPLING_PERCENTAGE\n  /* @min:samplingPercentage */\n  ] = function () {\n    return 100;\n  }, _a[_DYN_CUSTOM_HEADERS\n  /* @min:customHeaders */\n  ] = function () {\n    return defaultCustomHeaders;\n  }, _a[_DYN_CONVERT_UNDEFINED\n  /* @min:convertUndefined */\n  ] = function () {\n    return defaultValue;\n  }, _a[_DYN_EVENTS_LIMIT_IN_MEM\n  /* @min:eventsLimitInMem */\n  ] = function () {\n    return 10000;\n  }, _a.retryCodes = function () {\n    return null;\n  }, _a;\n}\n\nvar EnvelopeTypeCreator = (_a = {}, _a[Event.dataType] = EventEnvelopeCreator, _a[Trace.dataType] = TraceEnvelopeCreator, _a[PageView.dataType] = PageViewEnvelopeCreator, _a[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator, _a[Exception.dataType] = ExceptionEnvelopeCreator, _a[Metric.dataType] = MetricEnvelopeCreator, _a[RemoteDependencyData.dataType] = DependencyEnvelopeCreator, _a);\n\nvar Sender =\n/** @class */\nfunction (_super) {\n  __extends(Sender, _super);\n\n  function Sender() {\n    var _this = _super.call(this) || this;\n\n    _this.priority = 1001;\n    _this.identifier = BreezeChannelIdentifier;\n    /**\r\n     * The configuration for this sender instance\r\n     */\n\n    _this._senderConfig = _getDefaultAppInsightsChannelConfig(); // Don't set the defaults here, set them in the _initDefaults() as this is also called during unload\n\n    var _consecutiveErrors; // How many times in a row a retryable error condition has occurred.\n\n\n    var _retryAt; // The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).\n\n\n    var _lastSend; // The time of the last send operation.\n\n\n    var _paused; // Flag indicating that the sending should be paused\n\n\n    var _timeoutHandle; // Handle to the timer for delayed sending of batches of data.\n\n\n    var _serializer;\n\n    var _stamp_specific_redirects;\n\n    var _headers;\n\n    var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)\n\n    var _fallbackSender; // The sender to use if the payload size is too large\n\n\n    var _syncUnloadSender; // The identified sender to use for the synchronous unload stage\n\n\n    var _offlineListener;\n\n    var _evtNamespace;\n\n    var _retryCodes;\n\n    dynamicProto(Sender, _this, function (_self, _base) {\n      _initDefaults();\n\n      _self.pause = function () {\n        _clearScheduledTimer();\n\n        _paused = true;\n      };\n\n      _self.resume = function () {\n        if (_paused) {\n          _paused = false;\n          _retryAt = null; // flush if we have exceeded the max-size already\n\n          if (_self._buffer.size() > _self._senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1\n          /* @min:%2emaxBatchSizeInBytes */\n          ]()) {\n            _self[_DYN_TRIGGER_SEND\n            /* @min:%2etriggerSend */\n            ](true, null, 10\n            /* SendRequestReason.MaxBatchSize */\n            );\n          }\n\n          _setupTimer();\n        }\n      };\n\n      _self.flush = function (isAsync, callBack, sendReason) {\n        if (isAsync === void 0) {\n          isAsync = true;\n        }\n\n        if (!_paused) {\n          // Clear the normal schedule timer as we are going to try and flush ASAP\n          _clearScheduledTimer();\n\n          try {\n            _self[_DYN_TRIGGER_SEND\n            /* @min:%2etriggerSend */\n            ](isAsync, null, sendReason || 1\n            /* SendRequestReason.ManualFlush */\n            );\n          } catch (e) {\n            _throwInternal(_self[_DYN_DIAG_LOG\n            /* @min:%2ediagLog */\n            ](), 1\n            /* eLoggingSeverity.CRITICAL */\n            , 22\n            /* _eInternalMessageId.FlushFailed */\n            , \"flush failed, telemetry will not be collected: \" + getExceptionName(e), {\n              exception: dumpObj(e)\n            });\n          }\n        }\n      };\n\n      _self.onunloadFlush = function () {\n        if (!_paused) {\n          if ((_self._senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2\n          /* @min:%2eonunloadDisableBeacon */\n          ]() === false || _self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_IS_BEACON_API_DISABL3\n          /* @min:%2eisBeaconApiDisabled */\n          ]() === false) && isBeaconsSupported()) {\n            try {\n              _self[_DYN_TRIGGER_SEND\n              /* @min:%2etriggerSend */\n              ](true, _doUnloadSend, 2\n              /* SendRequestReason.Unload */\n              );\n            } catch (e) {\n              _throwInternal(_self[_DYN_DIAG_LOG\n              /* @min:%2ediagLog */\n              ](), 1\n              /* eLoggingSeverity.CRITICAL */\n              , 20\n              /* _eInternalMessageId.FailedToSendQueuedTelemetry */\n              , \"failed to flush with beacon sender on page unload, telemetry will not be collected: \" + getExceptionName(e), {\n                exception: dumpObj(e)\n              });\n            }\n          } else {\n            _self.flush();\n          }\n        }\n      };\n\n      _self.addHeader = function (name, value) {\n        _headers[name] = value;\n      };\n\n      _self.initialize = function (config, core, extensions, pluginChain) {\n        if (_self.isInitialized()) {\n          _throwInternal(_self[_DYN_DIAG_LOG\n          /* @min:%2ediagLog */\n          ](), 1\n          /* eLoggingSeverity.CRITICAL */\n          , 28\n          /* _eInternalMessageId.SenderNotInitialized */\n          , \"Sender is already initialized\");\n        }\n\n        _base.initialize(config, core, extensions, pluginChain);\n\n        var ctx = _self._getTelCtx();\n\n        var identifier = _self.identifier;\n        _serializer = new Serializer(core.logger);\n        _consecutiveErrors = 0;\n        _retryAt = null;\n        _lastSend = 0;\n        _self[_DYN__SENDER\n        /* @min:%2e_sender */\n        ] = null;\n        _stamp_specific_redirects = 0;\n\n        var diagLog = _self[_DYN_DIAG_LOG\n        /* @min:%2ediagLog */\n        ]();\n\n        _evtNamespace = mergeEvtNamespace(createUniqueNamespace(\"Sender\"), core.evtNamespace && core.evtNamespace());\n        _offlineListener = createOfflineListener(_evtNamespace); // TODO v3.x: Change the ISenderConfig to not be function calls\n\n        var defaultConfig = _getDefaultAppInsightsChannelConfig();\n\n        objForEachKey(defaultConfig, function (field, value) {\n          _self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][field] = function () {\n            var theValue = ctx.getConfig(identifier, field, value());\n\n            if (!theValue && field === \"endpointUrl\") {\n              // Use the default value (handles empty string in the configuration)\n              theValue = value();\n            }\n\n            return theValue;\n          };\n        });\n        _retryCodes = _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ].retryCodes();\n\n        if (config.storagePrefix) {\n          utlSetStoragePrefix(config.storagePrefix);\n        }\n\n        var useSessionStorage = _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ][_DYN_ENABLE_SESSION_STORA4\n        /* @min:%2eenableSessionStorageBuffer */\n        ]() && !!(_self._senderConfig[_DYN_BUFFER_OVERRIDE\n        /* @min:%2ebufferOverride */\n        ]() || utlCanUseSessionStorage());\n        _self[_DYN__BUFFER\n        /* @min:%2e_buffer */\n        ] = useSessionStorage ? new SessionStorageSendBuffer(diagLog, _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ]) : new ArraySendBuffer(diagLog, _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ]);\n        _self._sample = new Sample(_self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ][_DYN_SAMPLING_PERCENTAGE\n        /* @min:%2esamplingPercentage */\n        ](), diagLog);\n\n        if (!_validateInstrumentationKey(config)) {\n          _throwInternal(diagLog, 1\n          /* eLoggingSeverity.CRITICAL */\n          , 100\n          /* _eInternalMessageId.InvalidInstrumentationKey */\n          , \"Invalid Instrumentation key \" + config[_DYN_INSTRUMENTATION_KEY\n          /* @min:%2einstrumentationKey */\n          ]);\n        }\n\n        if (!isInternalApplicationInsightsEndpoint(_self._senderConfig.endpointUrl()) && _self._senderConfig.customHeaders() && _self._senderConfig.customHeaders()[_DYN_LENGTH\n        /* @min:%2elength */\n        ] > 0) {\n          arrForEach(_self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_CUSTOM_HEADERS\n          /* @min:%2ecustomHeaders */\n          ](), function (customHeader) {\n            _this.addHeader(customHeader.header, customHeader.value);\n          });\n        }\n\n        var senderConfig = _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ];\n        var sendPostFunc = null;\n\n        if (!senderConfig[_DYN_DISABLE_XHR\n        /* @min:%2edisableXhr */\n        ]() && useXDomainRequest()) {\n          sendPostFunc = _xdrSender; // IE 8 and 9\n        } else if (!senderConfig[_DYN_DISABLE_XHR\n        /* @min:%2edisableXhr */\n        ]() && isXhrSupported()) {\n          sendPostFunc = _xhrSender;\n        }\n\n        if (!sendPostFunc && isFetchSupported()) {\n          sendPostFunc = _fetchSender;\n        } // always fallback to XHR\n\n\n        _fallbackSender = sendPostFunc || _xhrSender;\n\n        if (!senderConfig[_DYN_IS_BEACON_API_DISABL3\n        /* @min:%2eisBeaconApiDisabled */\n        ]() && isBeaconsSupported()) {\n          // Config is set to always used beacon sending\n          sendPostFunc = _beaconSender;\n        }\n\n        _self[_DYN__SENDER\n        /* @min:%2e_sender */\n        ] = sendPostFunc || _xhrSender;\n\n        if (!senderConfig[_DYN_ONUNLOAD_DISABLE_FET5\n        /* @min:%2eonunloadDisableFetch */\n        ]() && isFetchSupported(true)) {\n          // Try and use the fetch with keepalive\n          _syncUnloadSender = _fetchKeepAliveSender;\n        } else if (isBeaconsSupported()) {\n          // Try and use sendBeacon\n          _syncUnloadSender = _beaconSender;\n        } else if (!senderConfig[_DYN_DISABLE_XHR\n        /* @min:%2edisableXhr */\n        ]() && useXDomainRequest()) {\n          _syncUnloadSender = _xdrSender; // IE 8 and 9\n        } else if (!senderConfig[_DYN_DISABLE_XHR\n        /* @min:%2edisableXhr */\n        ]() && isXhrSupported()) {\n          _syncUnloadSender = _xhrSender;\n        } else {\n          _syncUnloadSender = _fallbackSender;\n        }\n      };\n\n      _self.processTelemetry = function (telemetryItem, itemCtx) {\n        itemCtx = _self._getTelCtx(itemCtx);\n\n        var diagLogger = itemCtx[_DYN_DIAG_LOG\n        /* @min:%2ediagLog */\n        ]();\n\n        try {\n          // if master off switch is set, don't send any data\n          if (_self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_DISABLE_TELEMETRY\n          /* @min:%2edisableTelemetry */\n          ]()) {\n            // Do not send/save data\n            return;\n          } // validate input\n\n\n          if (!telemetryItem) {\n            _throwInternal(diagLogger, 1\n            /* eLoggingSeverity.CRITICAL */\n            , 7\n            /* _eInternalMessageId.CannotSendEmptyTelemetry */\n            , \"Cannot send empty telemetry\");\n\n            return;\n          } // validate event\n\n\n          if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE\n          /* @min:%2ebaseType */\n          ]) {\n            _throwInternal(diagLogger, 1\n            /* eLoggingSeverity.CRITICAL */\n            , 70\n            /* _eInternalMessageId.InvalidEvent */\n            , \"Cannot send telemetry without baseData and baseType\");\n\n            return;\n          }\n\n          if (!telemetryItem[_DYN_BASE_TYPE\n          /* @min:%2ebaseType */\n          ]) {\n            // Default\n            telemetryItem[_DYN_BASE_TYPE\n            /* @min:%2ebaseType */\n            ] = \"EventData\";\n          } // ensure a sender was constructed\n\n\n          if (!_self[_DYN__SENDER\n          /* @min:%2e_sender */\n          ]) {\n            _throwInternal(diagLogger, 1\n            /* eLoggingSeverity.CRITICAL */\n            , 28\n            /* _eInternalMessageId.SenderNotInitialized */\n            , \"Sender was not initialized\");\n\n            return;\n          } // check if this item should be sampled in, else add sampleRate tag\n\n\n          if (!_isSampledIn(telemetryItem)) {\n            // Item is sampled out, do not send it\n            _throwInternal(diagLogger, 2\n            /* eLoggingSeverity.WARNING */\n            , 33\n            /* _eInternalMessageId.TelemetrySampledAndNotSent */\n            , \"Telemetry item was sampled out and not sent\", {\n              SampleRate: _self._sample[_DYN_SAMPLE_RATE\n              /* @min:%2esampleRate */\n              ]\n            });\n\n            return;\n          } else {\n            telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE\n            /* @min:%2esampleRate */\n            ];\n          }\n\n          var convertUndefined = _self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_CONVERT_UNDEFINED\n          /* @min:%2econvertUndefined */\n          ]() || undefined; // construct an envelope that Application Insights endpoint can understand\n          // if ikey of telemetry is provided and not empty, envelope will use this iKey instead of senderConfig iKey\n\n          var defaultEnvelopeIkey = telemetryItem.iKey || _self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_INSTRUMENTATION_KEY\n          /* @min:%2einstrumentationKey */\n          ]();\n\n          var aiEnvelope_1 = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, convertUndefined);\n\n          if (!aiEnvelope_1) {\n            _throwInternal(diagLogger, 1\n            /* eLoggingSeverity.CRITICAL */\n            , 47\n            /* _eInternalMessageId.CreateEnvelopeError */\n            , \"Unable to create an AppInsights envelope\");\n\n            return;\n          }\n\n          var doNotSendItem_1 = false; // this is for running in legacy mode, where customer may already have a custom initializer present\n\n          if (telemetryItem[_DYN_TAGS\n          /* @min:%2etags */\n          ] && telemetryItem[_DYN_TAGS\n          /* @min:%2etags */\n          ][ProcessLegacy]) {\n            arrForEach(telemetryItem[_DYN_TAGS\n            /* @min:%2etags */\n            ][ProcessLegacy], function (callBack) {\n              try {\n                if (callBack && callBack(aiEnvelope_1) === false) {\n                  doNotSendItem_1 = true;\n\n                  _warnToConsole(diagLogger, \"Telemetry processor check returns false\");\n                }\n              } catch (e) {\n                // log error but dont stop executing rest of the telemetry initializers\n                // doNotSendItem = true;\n                _throwInternal(diagLogger, 1\n                /* eLoggingSeverity.CRITICAL */\n                , 64\n                /* _eInternalMessageId.TelemetryInitializerFailed */\n                , \"One of telemetry initializers failed, telemetry item will not be sent: \" + getExceptionName(e), {\n                  exception: dumpObj(e)\n                }, true);\n              }\n            });\n            delete telemetryItem[_DYN_TAGS\n            /* @min:%2etags */\n            ][ProcessLegacy];\n          }\n\n          if (doNotSendItem_1) {\n            return; // do not send, no need to execute next plugin\n          } // check if the incoming payload is too large, truncate if necessary\n\n\n          var payload = _serializer.serialize(aiEnvelope_1); // flush if we would exceed the max-size limit by adding this item\n\n\n          var buffer = _self[_DYN__BUFFER\n          /* @min:%2e_buffer */\n          ];\n          var bufferSize = buffer.size();\n\n          if (bufferSize + payload[_DYN_LENGTH\n          /* @min:%2elength */\n          ] > _self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_MAX_BATCH_SIZE_IN_BY1\n          /* @min:%2emaxBatchSizeInBytes */\n          ]()) {\n            if (!_offlineListener || _offlineListener[_DYN_IS_ONLINE\n            /* @min:%2eisOnline */\n            ]()) {\n              // only trigger send when currently online\n              _self[_DYN_TRIGGER_SEND\n              /* @min:%2etriggerSend */\n              ](true, null, 10\n              /* SendRequestReason.MaxBatchSize */\n              );\n            }\n          } // enqueue the payload\n\n\n          buffer[_DYN_ENQUEUE\n          /* @min:%2eenqueue */\n          ](payload); // ensure an invocation timeout is set\n\n\n          _setupTimer();\n        } catch (e) {\n          _throwInternal(diagLogger, 2\n          /* eLoggingSeverity.WARNING */\n          , 12\n          /* _eInternalMessageId.FailedAddingTelemetryToBuffer */\n          , \"Failed adding telemetry to the sender's buffer, some telemetry will be lost: \" + getExceptionName(e), {\n            exception: dumpObj(e)\n          });\n        } // hand off the telemetry item to the next plugin\n\n\n        _self.processNext(telemetryItem, itemCtx);\n      };\n      /**\r\n       * xhr state changes\r\n       */\n\n\n      _self[_DYN__XHR_READY_STATE_CHA6\n      /* @min:%2e_xhrReadyStateChange */\n      ] = function (xhr, payload, countOfItemsInPayload) {\n        if (xhr.readyState === 4) {\n          _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, _formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);\n        }\n      };\n      /**\r\n       * Immediately send buffered data\r\n       * @param async {boolean} - Indicates if the events should be sent asynchronously\r\n       * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n       */\n\n\n      _self[_DYN_TRIGGER_SEND\n      /* @min:%2etriggerSend */\n      ] = function (async, forcedSender, sendReason) {\n        if (async === void 0) {\n          async = true;\n        }\n\n        if (!_paused) {\n          try {\n            var buffer = _self[_DYN__BUFFER\n            /* @min:%2e_buffer */\n            ]; // Send data only if disableTelemetry is false\n\n            if (!_self[_DYN__SENDER_CONFIG\n            /* @min:%2e_senderConfig */\n            ][_DYN_DISABLE_TELEMETRY\n            /* @min:%2edisableTelemetry */\n            ]()) {\n              if (buffer[_DYN_COUNT\n              /* @min:%2ecount */\n              ]() > 0) {\n                var payload = buffer.getItems();\n\n                _notifySendRequest(sendReason || 0\n                /* SendRequestReason.Undefined */\n                , async); // invoke send\n\n\n                if (forcedSender) {\n                  forcedSender.call(_self, payload, async);\n                } else {\n                  _self[_DYN__SENDER\n                  /* @min:%2e_sender */\n                  ](payload, async);\n                }\n              } // update lastSend time to enable throttling\n\n\n              _lastSend = +new Date();\n            } else {\n              buffer[_DYN_CLEAR\n              /* @min:%2eclear */\n              ]();\n            }\n\n            _clearScheduledTimer();\n          } catch (e) {\n            /* Ignore this error for IE under v10 */\n            var ieVer = getIEVersion();\n\n            if (!ieVer || ieVer > 9) {\n              _throwInternal(_self[_DYN_DIAG_LOG\n              /* @min:%2ediagLog */\n              ](), 1\n              /* eLoggingSeverity.CRITICAL */\n              , 40\n              /* _eInternalMessageId.TransmissionFailed */\n              , \"Telemetry transmission failed, some telemetry will be lost: \" + getExceptionName(e), {\n                exception: dumpObj(e)\n              });\n            }\n          }\n        }\n      };\n\n      _self._doTeardown = function (unloadCtx, unloadState) {\n        _self.onunloadFlush();\n\n        _offlineListener.unload();\n\n        _initDefaults();\n      };\n      /**\r\n       * error handler\r\n       */\n\n\n      _self[_DYN__ON_ERROR\n      /* @min:%2e_onError */\n      ] = function (payload, message, event) {\n        _throwInternal(_self[_DYN_DIAG_LOG\n        /* @min:%2ediagLog */\n        ](), 2\n        /* eLoggingSeverity.WARNING */\n        , 26\n        /* _eInternalMessageId.OnError */\n        , \"Failed to send telemetry.\", {\n          message: message\n        });\n\n        _self._buffer && _self._buffer[_DYN_CLEAR_SENT\n        /* @min:%2eclearSent */\n        ](payload);\n      };\n      /**\r\n       * partial success handler\r\n       */\n\n\n      _self[_DYN__ON_PARTIAL_SUCCESS\n      /* @min:%2e_onPartialSuccess */\n      ] = function (payload, results) {\n        var failed = [];\n        var retry = []; // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.\n\n        var errors = results.errors.reverse();\n\n        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n          var error = errors_1[_i];\n          var extracted = payload.splice(error.index, 1)[0];\n\n          if (_isRetriable(error.statusCode)) {\n            retry[_DYN_PUSH\n            /* @min:%2epush */\n            ](extracted);\n          } else {\n            // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).\n            failed[_DYN_PUSH\n            /* @min:%2epush */\n            ](extracted);\n          }\n        }\n\n        if (payload[_DYN_LENGTH\n        /* @min:%2elength */\n        ] > 0) {\n          _self[_DYN__ON_SUCCESS\n          /* @min:%2e_onSuccess */\n          ](payload, results[_DYN_ITEMS_ACCEPTED\n          /* @min:%2eitemsAccepted */\n          ]);\n        }\n\n        if (failed[_DYN_LENGTH\n        /* @min:%2elength */\n        ] > 0) {\n          _self[_DYN__ON_ERROR\n          /* @min:%2e_onError */\n          ](failed, _formatErrorMessageXhr(null, [\"partial success\", results[_DYN_ITEMS_ACCEPTED\n          /* @min:%2eitemsAccepted */\n          ], \"of\", results.itemsReceived].join(\" \")));\n        }\n\n        if (retry[_DYN_LENGTH\n        /* @min:%2elength */\n        ] > 0) {\n          _resendPayload(retry);\n\n          _throwInternal(_self[_DYN_DIAG_LOG\n          /* @min:%2ediagLog */\n          ](), 2\n          /* eLoggingSeverity.WARNING */\n          , 40\n          /* _eInternalMessageId.TransmissionFailed */\n          , \"Partial success. \" + \"Delivered: \" + payload[_DYN_LENGTH\n          /* @min:%2elength */\n          ] + \", Failed: \" + failed[_DYN_LENGTH\n          /* @min:%2elength */\n          ] + \". Will retry to send \" + retry[_DYN_LENGTH\n          /* @min:%2elength */\n          ] + \" our of \" + results[_DYN_ITEMS_RECEIVED\n          /* @min:%2eitemsReceived */\n          ] + \" items\");\n        }\n      };\n      /**\r\n       * success handler\r\n       */\n\n\n      _self[_DYN__ON_SUCCESS\n      /* @min:%2e_onSuccess */\n      ] = function (payload, countOfItemsInPayload) {\n        _self._buffer && _self._buffer[_DYN_CLEAR_SENT\n        /* @min:%2eclearSent */\n        ](payload);\n      };\n      /**\r\n       * xdr state changes\r\n       */\n\n\n      _self._xdrOnLoad = function (xdr, payload) {\n        var responseText = _getResponseText(xdr);\n\n        if (xdr && (responseText + \"\" === \"200\" || responseText === \"\")) {\n          _consecutiveErrors = 0;\n\n          _self[_DYN__ON_SUCCESS\n          /* @min:%2e_onSuccess */\n          ](payload, 0);\n        } else {\n          var results = _parseResponse(responseText);\n\n          if (results && results.itemsReceived && results.itemsReceived > results[_DYN_ITEMS_ACCEPTED\n          /* @min:%2eitemsAccepted */\n          ] && !_self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_IS_RETRY_DISABLED\n          /* @min:%2eisRetryDisabled */\n          ]()) {\n            _self[_DYN__ON_PARTIAL_SUCCESS\n            /* @min:%2e_onPartialSuccess */\n            ](payload, results);\n          } else {\n            _self[_DYN__ON_ERROR\n            /* @min:%2e_onError */\n            ](payload, _formatErrorMessageXdr(xdr));\n          }\n        }\n      };\n\n      function _isSampledIn(envelope) {\n        return _self._sample.isSampledIn(envelope);\n      }\n\n      function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {\n        var response = null;\n\n        if (!_self._appId) {\n          response = _parseResponse(res);\n\n          if (response && response.appId) {\n            _self._appId = response.appId;\n          }\n        }\n\n        if ((status < 200 || status >= 300) && status !== 0) {\n          // Update End Point url if permanent redirect or moved permanently\n          // Updates the end point url before retry\n          if (status === 301 || status === 307 || status === 308) {\n            if (!_checkAndUpdateEndPointUrl(responseUrl)) {\n              _self[_DYN__ON_ERROR\n              /* @min:%2e_onError */\n              ](payload, errorMessage);\n\n              return;\n            }\n          }\n\n          if (!_self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_IS_RETRY_DISABLED\n          /* @min:%2eisRetryDisabled */\n          ]() && _isRetriable(status)) {\n            _resendPayload(payload);\n\n            _throwInternal(_self[_DYN_DIAG_LOG\n            /* @min:%2ediagLog */\n            ](), 2\n            /* eLoggingSeverity.WARNING */\n            , 40\n            /* _eInternalMessageId.TransmissionFailed */\n            , \". \" + \"Response code \" + status + \". Will retry to send \" + payload[_DYN_LENGTH\n            /* @min:%2elength */\n            ] + \" items.\");\n          } else {\n            _self[_DYN__ON_ERROR\n            /* @min:%2e_onError */\n            ](payload, errorMessage);\n          }\n        } else if (_offlineListener && !_offlineListener[_DYN_IS_ONLINE\n        /* @min:%2eisOnline */\n        ]()) {\n          // offline\n          // Note: Don't check for status == 0, since adblock gives this code\n          if (!_self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_IS_RETRY_DISABLED\n          /* @min:%2eisRetryDisabled */\n          ]()) {\n            var offlineBackOffMultiplier = 10; // arbritrary number\n\n            _resendPayload(payload, offlineBackOffMultiplier);\n\n            _throwInternal(_self[_DYN_DIAG_LOG\n            /* @min:%2ediagLog */\n            ](), 2\n            /* eLoggingSeverity.WARNING */\n            , 40\n            /* _eInternalMessageId.TransmissionFailed */\n            , \". Offline - Response Code: \".concat(status, \". Offline status: \").concat(!_offlineListener.isOnline(), \". Will retry to send \").concat(payload.length, \" items.\"));\n          }\n        } else {\n          // check if the xhr's responseURL or fetch's response.url is same as endpoint url\n          // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.\n          _checkAndUpdateEndPointUrl(responseUrl);\n\n          if (status === 206) {\n            if (!response) {\n              response = _parseResponse(res);\n            }\n\n            if (response && !_self[_DYN__SENDER_CONFIG\n            /* @min:%2e_senderConfig */\n            ][_DYN_IS_RETRY_DISABLED\n            /* @min:%2eisRetryDisabled */\n            ]()) {\n              _self[_DYN__ON_PARTIAL_SUCCESS\n              /* @min:%2e_onPartialSuccess */\n              ](payload, response);\n            } else {\n              _self[_DYN__ON_ERROR\n              /* @min:%2e_onError */\n              ](payload, errorMessage);\n            }\n          } else {\n            _consecutiveErrors = 0;\n\n            _self[_DYN__ON_SUCCESS\n            /* @min:%2e_onSuccess */\n            ](payload, countOfItemsInPayload);\n          }\n        }\n      }\n\n      function _checkAndUpdateEndPointUrl(responseUrl) {\n        // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)\n        if (_stamp_specific_redirects >= 10) {\n          //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+\"/?redirect=false\";\n          //  _stamp_specific_redirects = 0;\n          return false;\n        }\n\n        if (!isNullOrUndefined(responseUrl) && responseUrl !== \"\") {\n          if (responseUrl !== _self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_ENDPOINT_URL\n          /* @min:%2eendpointUrl */\n          ]()) {\n            _self[_DYN__SENDER_CONFIG\n            /* @min:%2e_senderConfig */\n            ][_DYN_ENDPOINT_URL\n            /* @min:%2eendpointUrl */\n            ] = function () {\n              return responseUrl;\n            };\n\n            ++_stamp_specific_redirects;\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function _doUnloadSend(payload, isAsync) {\n        if (_syncUnloadSender) {\n          // We are unloading so always call the sender with sync set to false\n          _syncUnloadSender(payload, false);\n        } else {\n          // Fallback to the previous beacon Sender (which causes a CORB warning on chrome now)\n          _beaconSender(payload, isAsync);\n        }\n      }\n\n      function _doBeaconSend(payload) {\n        var nav = getNavigator();\n        var buffer = _self[_DYN__BUFFER\n        /* @min:%2e_buffer */\n        ];\n\n        var url = _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ][_DYN_ENDPOINT_URL\n        /* @min:%2eendpointUrl */\n        ]();\n\n        var batch = _self._buffer[_DYN_BATCH_PAYLOADS\n        /* @min:%2ebatchPayloads */\n        ](payload); // Chrome only allows CORS-safelisted values for the sendBeacon data argument\n        // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\n\n\n        var plainTextBatch = new Blob([batch], {\n          type: \"text/plain;charset=UTF-8\"\n        }); // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\n\n        var queued = nav.sendBeacon(url, plainTextBatch);\n\n        if (queued) {\n          buffer[_DYN_MARK_AS_SENT\n          /* @min:%2emarkAsSent */\n          ](payload); // no response from beaconSender, clear buffer\n\n\n          _self._onSuccess(payload, payload[_DYN_LENGTH\n          /* @min:%2elength */\n          ]);\n        }\n\n        return queued;\n      }\n      /**\r\n       * Send Beacon API request\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - not used\r\n       * Note: Beacon API does not support custom headers and we are not able to get\r\n       * appId from the backend for the correct correlation.\r\n       */\n\n\n      function _beaconSender(payload, isAsync) {\n        if (isArray(payload) && payload[_DYN_LENGTH\n        /* @min:%2elength */\n        ] > 0) {\n          // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\n          if (!_doBeaconSend(payload)) {\n            // Failed to send entire payload so try and split data and try to send as much events as possible\n            var droppedPayload = [];\n\n            for (var lp = 0; lp < payload[_DYN_LENGTH\n            /* @min:%2elength */\n            ]; lp++) {\n              var thePayload = payload[lp];\n\n              if (!_doBeaconSend([thePayload])) {\n                // Can't send anymore, so split the batch and drop the rest\n                droppedPayload[_DYN_PUSH\n                /* @min:%2epush */\n                ](thePayload);\n              }\n            }\n\n            if (droppedPayload[_DYN_LENGTH\n            /* @min:%2elength */\n            ] > 0) {\n              _fallbackSender && _fallbackSender(droppedPayload, true);\n\n              _throwInternal(_self[_DYN_DIAG_LOG\n              /* @min:%2ediagLog */\n              ](), 2\n              /* eLoggingSeverity.WARNING */\n              , 40\n              /* _eInternalMessageId.TransmissionFailed */\n              , \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\n            }\n          }\n        }\n      }\n      /**\r\n       * Send XMLHttpRequest\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n       */\n\n\n      function _xhrSender(payload, isAsync) {\n        var xhr = new XMLHttpRequest();\n\n        var endPointUrl = _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ][_DYN_ENDPOINT_URL\n        /* @min:%2eendpointUrl */\n        ]();\n\n        try {\n          xhr[DisabledPropertyName] = true;\n        } catch (e) {// If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\n          // cause the request to fail and we no telemetry would be sent\n        }\n\n        xhr.open(\"POST\", endPointUrl, isAsync);\n\n        xhr[_DYN_SET_REQUEST_HEADER\n        /* @min:%2esetRequestHeader */\n        ](\"Content-type\", \"application/json\"); // append Sdk-Context request header only in case of breeze endpoint\n\n\n        if (isInternalApplicationInsightsEndpoint(endPointUrl)) {\n          xhr[_DYN_SET_REQUEST_HEADER\n          /* @min:%2esetRequestHeader */\n          ](RequestHeaders[6\n          /* eRequestHeaders.sdkContextHeader */\n          ], RequestHeaders[7\n          /* eRequestHeaders.sdkContextHeaderAppIdRequest */\n          ]);\n        }\n\n        arrForEach(objKeys(_headers), function (headerName) {\n          xhr[_DYN_SET_REQUEST_HEADER\n          /* @min:%2esetRequestHeader */\n          ](headerName, _headers[headerName]);\n        });\n\n        xhr.onreadystatechange = function () {\n          return _self._xhrReadyStateChange(xhr, payload, payload[_DYN_LENGTH\n          /* @min:%2elength */\n          ]);\n        };\n\n        xhr.onerror = function (event) {\n          return _self[_DYN__ON_ERROR\n          /* @min:%2e_onError */\n          ](payload, _formatErrorMessageXhr(xhr), event);\n        }; // compose an array of payloads\n\n\n        var batch = _self._buffer[_DYN_BATCH_PAYLOADS\n        /* @min:%2ebatchPayloads */\n        ](payload);\n\n        xhr.send(batch);\n\n        _self._buffer[_DYN_MARK_AS_SENT\n        /* @min:%2emarkAsSent */\n        ](payload);\n      }\n\n      function _fetchKeepAliveSender(payload, isAsync) {\n        if (isArray(payload)) {\n          var payloadSize = payload[_DYN_LENGTH\n          /* @min:%2elength */\n          ];\n\n          for (var lp = 0; lp < payload[_DYN_LENGTH\n          /* @min:%2elength */\n          ]; lp++) {\n            payloadSize += payload[lp][_DYN_LENGTH\n            /* @min:%2elength */\n            ];\n          }\n\n          if (_syncFetchPayload + payloadSize <= FetchSyncRequestSizeLimitBytes) {\n            _doFetchSender(payload, false);\n          } else if (isBeaconsSupported()) {\n            // Fallback to beacon sender as we at least get told which events can't be scheduled\n            _beaconSender(payload, isAsync);\n          } else {\n            // Payload is going to be too big so just try and send via XHR\n            _fallbackSender && _fallbackSender(payload, true);\n\n            _throwInternal(_self[_DYN_DIAG_LOG\n            /* @min:%2ediagLog */\n            ](), 2\n            /* eLoggingSeverity.WARNING */\n            , 40\n            /* _eInternalMessageId.TransmissionFailed */\n            , \". \" + \"Failed to send telemetry with Beacon API, retried with xhrSender.\");\n          }\n        }\n      }\n      /**\r\n       * Send fetch API request\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - not used\r\n       */\n\n\n      function _fetchSender(payload, isAsync) {\n        _doFetchSender(payload, true);\n      }\n      /**\r\n       * Send fetch API request\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - For fetch this identifies whether we are \"unloading\" (false) or a normal request\r\n       */\n\n\n      function _doFetchSender(payload, isAsync) {\n        var _a;\n\n        var endPointUrl = _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ][_DYN_ENDPOINT_URL\n        /* @min:%2eendpointUrl */\n        ]();\n\n        var batch = _self._buffer[_DYN_BATCH_PAYLOADS\n        /* @min:%2ebatchPayloads */\n        ](payload);\n\n        var plainTextBatch = new Blob([batch], {\n          type: \"application/json\"\n        });\n        var requestHeaders = new Headers();\n        var batchLength = batch[_DYN_LENGTH\n        /* @min:%2elength */\n        ];\n        var ignoreResponse = false;\n        var responseHandled = false; // append Sdk-Context request header only in case of breeze endpoint\n\n        if (isInternalApplicationInsightsEndpoint(endPointUrl)) {\n          requestHeaders.append(RequestHeaders[6\n          /* eRequestHeaders.sdkContextHeader */\n          ], RequestHeaders[7\n          /* eRequestHeaders.sdkContextHeaderAppIdRequest */\n          ]);\n        }\n\n        arrForEach(objKeys(_headers), function (headerName) {\n          requestHeaders.append(headerName, _headers[headerName]);\n        });\n        var init = (_a = {\n          method: \"POST\",\n          headers: requestHeaders,\n          body: plainTextBatch\n        }, _a[DisabledPropertyName] = true // Mark so we don't attempt to track this request\n        , _a);\n\n        if (!isAsync) {\n          init.keepalive = true; // As a sync request (during unload), it is unlikely that we will get a chance to process the response so\n          // just like beacon send assume that the events have been accepted and processed\n\n          ignoreResponse = true;\n          _syncFetchPayload += batchLength;\n        }\n\n        var request = new Request(endPointUrl, init);\n\n        try {\n          // Also try and tag the request (just in case the value in init is not copied over)\n          request[DisabledPropertyName] = true;\n        } catch (e) {// If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\n          // cause the request to fail and we no telemetry would be sent\n        }\n\n        _self._buffer[_DYN_MARK_AS_SENT\n        /* @min:%2emarkAsSent */\n        ](payload);\n\n        try {\n          fetch(request).then(function (response) {\n            if (!isAsync) {\n              _syncFetchPayload -= batchLength;\n              batchLength = 0;\n            }\n\n            if (!responseHandled) {\n              responseHandled = true;\n              /**\r\n               * The Promise returned from fetch() wonâ€™t reject on HTTP error status even if the response is an HTTP 404 or 500.\r\n               * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure\r\n               * or if anything prevented the request from completing.\r\n               */\n\n              if (!response.ok) {\n                _self[_DYN__ON_ERROR\n                /* @min:%2e_onError */\n                ](payload, response.statusText);\n              } else {\n                response.text().then(function (text) {\n                  _checkResponsStatus(response.status, payload, response.url, payload[_DYN_LENGTH\n                  /* @min:%2elength */\n                  ], response.statusText, text);\n                });\n              }\n            }\n          })[\"catch\"](function (error) {\n            if (!isAsync) {\n              _syncFetchPayload -= batchLength;\n              batchLength = 0;\n            }\n\n            if (!responseHandled) {\n              responseHandled = true;\n\n              _self[_DYN__ON_ERROR\n              /* @min:%2e_onError */\n              ](payload, error.message);\n            }\n          });\n        } catch (e) {\n          if (!responseHandled) {\n            _self[_DYN__ON_ERROR\n            /* @min:%2e_onError */\n            ](payload, dumpObj(e));\n          }\n        }\n\n        if (ignoreResponse && !responseHandled) {\n          // Assume success during unload processing as we most likely won't get the response\n          responseHandled = true;\n\n          _self._onSuccess(payload, payload[_DYN_LENGTH\n          /* @min:%2elength */\n          ]);\n        }\n      }\n      /**\r\n       * Parses the response from the backend.\r\n       * @param response - XMLHttpRequest or XDomainRequest response\r\n       */\n\n\n      function _parseResponse(response) {\n        try {\n          if (response && response !== \"\") {\n            var result = getJSON().parse(response);\n\n            if (result && result.itemsReceived && result.itemsReceived >= result[_DYN_ITEMS_ACCEPTED\n            /* @min:%2eitemsAccepted */\n            ] && result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH\n            /* @min:%2elength */\n            ]) {\n              return result;\n            }\n          }\n        } catch (e) {\n          _throwInternal(_self[_DYN_DIAG_LOG\n          /* @min:%2ediagLog */\n          ](), 1\n          /* eLoggingSeverity.CRITICAL */\n          , 43\n          /* _eInternalMessageId.InvalidBackendResponse */\n          , \"Cannot parse the response. \" + getExceptionName(e), {\n            response: response\n          });\n        }\n\n        return null;\n      }\n      /**\r\n       * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).\r\n       * @param payload\r\n       */\n\n\n      function _resendPayload(payload, linearFactor) {\n        if (linearFactor === void 0) {\n          linearFactor = 1;\n        }\n\n        if (!payload || payload[_DYN_LENGTH\n        /* @min:%2elength */\n        ] === 0) {\n          return;\n        }\n\n        var buffer = _self[_DYN__BUFFER\n        /* @min:%2e_buffer */\n        ];\n\n        buffer[_DYN_CLEAR_SENT\n        /* @min:%2eclearSent */\n        ](payload);\n\n        _consecutiveErrors++;\n\n        for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {\n          var item = payload_1[_i];\n\n          buffer[_DYN_ENQUEUE\n          /* @min:%2eenqueue */\n          ](item);\n        } // setup timer\n\n\n        _setRetryTime(linearFactor);\n\n        _setupTimer();\n      }\n      /**\r\n       * Calculates the time to wait before retrying in case of an error based on\r\n       * http://en.wikipedia.org/wiki/Exponential_backoff\r\n       */\n\n\n      function _setRetryTime(linearFactor) {\n        var SlotDelayInSeconds = 10;\n        var delayInSeconds;\n\n        if (_consecutiveErrors <= 1) {\n          delayInSeconds = SlotDelayInSeconds;\n        } else {\n          var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2; // tslint:disable-next-line:insecure-random\n\n          var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;\n          backOffDelay = linearFactor * backOffDelay;\n          delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);\n        } // TODO: Log the backoff time like the C# version does.\n\n\n        var retryAfterTimeSpan = dateNow() + delayInSeconds * 1000; // TODO: Log the retry at time like the C# version does.\n\n        _retryAt = retryAfterTimeSpan;\n      }\n      /**\r\n       * Sets up the timer which triggers actually sending the data.\r\n       */\n\n\n      function _setupTimer() {\n        if (!_timeoutHandle && !_paused) {\n          var retryInterval = _retryAt ? Math.max(0, _retryAt - dateNow()) : 0;\n          var timerValue = Math.max(_self[_DYN__SENDER_CONFIG\n          /* @min:%2e_senderConfig */\n          ][_DYN_MAX_BATCH_INTERVAL\n          /* @min:%2emaxBatchInterval */\n          ](), retryInterval);\n          _timeoutHandle = setTimeout(function () {\n            _timeoutHandle = null;\n\n            _self[_DYN_TRIGGER_SEND\n            /* @min:%2etriggerSend */\n            ](true, null, 1\n            /* SendRequestReason.NormalSchedule */\n            );\n          }, timerValue);\n        }\n      }\n\n      function _clearScheduledTimer() {\n        clearTimeout(_timeoutHandle);\n        _timeoutHandle = null;\n        _retryAt = null;\n      }\n      /**\r\n       * Checks if the SDK should resend the payload after receiving this status code from the backend.\r\n       * @param statusCode\r\n       */\n\n\n      function _isRetriable(statusCode) {\n        // retryCodes = [] means should not retry\n        if (!isNullOrUndefined(_retryCodes)) {\n          return _retryCodes[_DYN_LENGTH\n          /* @min:%2elength */\n          ] && arrIndexOf(_retryCodes, statusCode) > -1;\n        }\n\n        return statusCode === 401 // Unauthorized\n        // Removing as private links can return a 403 which causes excessive retries and session storage usage\n        //|| statusCode === 403 // Forbidden\n        || statusCode === 408 // Timeout\n        || statusCode === 429 // Too many requests.\n        || statusCode === 500 // Internal server error.\n        || statusCode === 502 // Bad Gateway.\n        || statusCode === 503 // Service unavailable.\n        || statusCode === 504; // Gateway timeout.\n      }\n\n      function _formatErrorMessageXhr(xhr, message) {\n        if (xhr) {\n          return \"XMLHttpRequest,Status:\" + xhr.status + \",Response:\" + _getResponseText(xhr) || xhr.response || \"\";\n        }\n\n        return message;\n      }\n      /**\r\n       * Send XDomainRequest\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n       *\r\n       * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added\r\n       * to maintain consistency with the xhrSender's contract\r\n       * Note: XDomainRequest does not support custom headers and we are not able to get\r\n       * appId from the backend for the correct correlation.\r\n       */\n\n\n      function _xdrSender(payload, isAsync) {\n        var buffer = _self[_DYN__BUFFER\n        /* @min:%2e_buffer */\n        ];\n\n        var _window = getWindow();\n\n        var xdr = new XDomainRequest();\n\n        xdr.onload = function () {\n          return _self._xdrOnLoad(xdr, payload);\n        };\n\n        xdr.onerror = function (event) {\n          return _self[_DYN__ON_ERROR\n          /* @min:%2e_onError */\n          ](payload, _formatErrorMessageXdr(xdr), event);\n        }; // XDomainRequest requires the same protocol as the hosting page.\n        // If the protocol doesn't match, we can't send the telemetry :(.\n\n\n        var hostingProtocol = _window && _window.location && _window.location.protocol || \"\";\n\n        if (_self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ][_DYN_ENDPOINT_URL\n        /* @min:%2eendpointUrl */\n        ]().lastIndexOf(hostingProtocol, 0) !== 0) {\n          _throwInternal(_self[_DYN_DIAG_LOG\n          /* @min:%2ediagLog */\n          ](), 2\n          /* eLoggingSeverity.WARNING */\n          , 40\n          /* _eInternalMessageId.TransmissionFailed */\n          , \". \" + \"Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.\");\n\n          buffer[_DYN_CLEAR\n          /* @min:%2eclear */\n          ]();\n\n          return;\n        }\n\n        var endpointUrl = _self[_DYN__SENDER_CONFIG\n        /* @min:%2e_senderConfig */\n        ][_DYN_ENDPOINT_URL\n        /* @min:%2eendpointUrl */\n        ]().replace(/^(https?:)/, \"\");\n\n        xdr.open(\"POST\", endpointUrl); // compose an array of payloads\n\n        var batch = buffer[_DYN_BATCH_PAYLOADS\n        /* @min:%2ebatchPayloads */\n        ](payload);\n\n        xdr.send(batch);\n\n        buffer[_DYN_MARK_AS_SENT\n        /* @min:%2emarkAsSent */\n        ](payload);\n      }\n\n      function _formatErrorMessageXdr(xdr, message) {\n        if (xdr) {\n          return \"XDomainRequest,Response:\" + _getResponseText(xdr) || \"\";\n        }\n\n        return message;\n      } // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6\n\n\n      function _getNotifyMgr() {\n        var func = \"getNotifyMgr\";\n\n        if (_self.core[func]) {\n          return _self.core[func]();\n        } // using _self.core['_notificationManager'] for backward compatibility\n\n\n        return _self.core[\"_notificationManager\"];\n      }\n\n      function _notifySendRequest(sendRequest, isAsync) {\n        var manager = _getNotifyMgr();\n\n        if (manager && manager[_DYN_EVENTS_SEND_REQUEST\n        /* @min:%2eeventsSendRequest */\n        ]) {\n          try {\n            manager[_DYN_EVENTS_SEND_REQUEST\n            /* @min:%2eeventsSendRequest */\n            ](sendRequest, isAsync);\n          } catch (e) {\n            _throwInternal(_self[_DYN_DIAG_LOG\n            /* @min:%2ediagLog */\n            ](), 1\n            /* eLoggingSeverity.CRITICAL */\n            , 74\n            /* _eInternalMessageId.NotificationException */\n            , \"send request notification failed: \" + getExceptionName(e), {\n              exception: dumpObj(e)\n            });\n          }\n        }\n      }\n      /**\r\n       * Validate UUID Format\r\n       * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo\r\n       */\n\n\n      function _validateInstrumentationKey(config) {\n        var disableIKeyValidationFlag = isNullOrUndefined(config[_DYN_DISABLE_INSTRUMENTAT7\n        /* @min:%2edisableInstrumentationKeyValidation */\n        ]) ? false : config[_DYN_DISABLE_INSTRUMENTAT7\n        /* @min:%2edisableInstrumentationKeyValidation */\n        ];\n\n        if (disableIKeyValidationFlag) {\n          return true;\n        }\n\n        var UUID_Regex = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\";\n        var regexp = new RegExp(UUID_Regex);\n        return regexp.test(config[_DYN_INSTRUMENTATION_KEY\n        /* @min:%2einstrumentationKey */\n        ]);\n      }\n\n      function _initDefaults() {\n        _self[_DYN__SENDER\n        /* @min:%2e_sender */\n        ] = null;\n        _self[_DYN__BUFFER\n        /* @min:%2e_buffer */\n        ] = null;\n        _self._appId = null;\n        _self._sample = null;\n        _headers = {};\n        _offlineListener = null;\n        _consecutiveErrors = 0;\n        _retryAt = null;\n        _lastSend = null;\n        _paused = false;\n        _timeoutHandle = null;\n        _serializer = null;\n        _stamp_specific_redirects = 0;\n        _syncFetchPayload = 0;\n        _fallbackSender = null;\n        _syncUnloadSender = null;\n        _evtNamespace = null;\n      }\n    });\n    return _this;\n  }\n\n  Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {\n    var envelope;\n\n    if (iKey !== orig.iKey && !isNullOrUndefined(iKey)) {\n      envelope = __assign(__assign({}, orig), {\n        iKey: iKey\n      });\n    } else {\n      envelope = orig;\n    }\n\n    var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;\n    return creator(logger, envelope, convertUndefined);\n  }; // Removed Stub for Sender.prototype.pause.\n  // Removed Stub for Sender.prototype.resume.\n  // Removed Stub for Sender.prototype.flush.\n  // Removed Stub for Sender.prototype.onunloadFlush.\n  // Removed Stub for Sender.prototype.initialize.\n  // Removed Stub for Sender.prototype.processTelemetry.\n  // Removed Stub for Sender.prototype._xhrReadyStateChange.\n  // Removed Stub for Sender.prototype.triggerSend.\n  // Removed Stub for Sender.prototype._onError.\n  // Removed Stub for Sender.prototype._onPartialSuccess.\n  // Removed Stub for Sender.prototype._onSuccess.\n  // Removed Stub for Sender.prototype._xdrOnLoad.\n  // Removed Stub for Sender.prototype.addHeader.\n\n\n  return Sender;\n}(BaseTelemetryPlugin);\n\nexport { Sender }; //# sourceMappingURL=Sender.js.map","map":null,"metadata":{},"sourceType":"module"}