{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.18\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_IS_ASYNC, _DYN_IS_CHILD_EVT, _DYN_LISTENERS, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_2, _DYN_SPLICE } from \"../__DynamicConstants\";\nimport { arrForEach, arrIndexOf } from \"./HelperFuncs\";\nimport { STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_EVENTS_SENT, STR_PERF_EVENT } from \"./InternalConstants\";\n\nfunction _runListeners(listeners, name, isAsync, callback) {\n  arrForEach(listeners, function (listener) {\n    if (listener && listener[name]) {\n      if (isAsync) {\n        setTimeout(function () {\n          return callback(listener);\n        }, 0);\n      } else {\n        try {\n          callback(listener);\n        } catch (e) {// Catch errors to ensure we don't block sending the requests\n        }\n      }\n    }\n  });\n}\n/**\r\n * Class to manage sending notifications to all the listeners.\r\n */\n\n\nvar NotificationManager =\n/** @class */\nfunction () {\n  function NotificationManager(config) {\n    this.listeners = [];\n    var perfEvtsSendAll = !!(config || {}).perfEvtsSendAll;\n    dynamicProto(NotificationManager, this, function (_self) {\n      _self[_DYN_ADD_NOTIFICATION_LIS1\n      /* @min:%2eaddNotificationListener */\n      ] = function (listener) {\n        _self.listeners[_DYN_PUSH\n        /* @min:%2epush */\n        ](listener);\n      };\n      /**\r\n       * Removes all instances of the listener.\r\n       * @param {INotificationListener} listener - AWTNotificationListener to remove.\r\n       */\n\n\n      _self[_DYN_REMOVE_NOTIFICATION_2\n      /* @min:%2eremoveNotificationListener */\n      ] = function (listener) {\n        var index = arrIndexOf(_self[_DYN_LISTENERS\n        /* @min:%2elisteners */\n        ], listener);\n\n        while (index > -1) {\n          _self.listeners[_DYN_SPLICE\n          /* @min:%2esplice */\n          ](index, 1);\n\n          index = arrIndexOf(_self[_DYN_LISTENERS\n          /* @min:%2elisteners */\n          ], listener);\n        }\n      };\n      /**\r\n       * Notification for events sent.\r\n       * @param {ITelemetryItem[]} events - The array of events that have been sent.\r\n       */\n\n\n      _self[STR_EVENTS_SENT\n      /* @min:%2eeventsSent */\n      ] = function (events) {\n        _runListeners(_self[_DYN_LISTENERS\n        /* @min:%2elisteners */\n        ], STR_EVENTS_SENT, true, function (listener) {\n          listener[STR_EVENTS_SENT\n          /* @min:%2eeventsSent */\n          ](events);\n        });\n      };\n      /**\r\n       * Notification for events being discarded.\r\n       * @param {ITelemetryItem[]} events - The array of events that have been discarded by the SDK.\r\n       * @param {number} reason           - The reason for which the SDK discarded the events. The EventsDiscardedReason\r\n       * constant should be used to check the different values.\r\n       */\n\n\n      _self[STR_EVENTS_DISCARDED\n      /* @min:%2eeventsDiscarded */\n      ] = function (events, reason) {\n        _runListeners(_self[_DYN_LISTENERS\n        /* @min:%2elisteners */\n        ], STR_EVENTS_DISCARDED, true, function (listener) {\n          listener[STR_EVENTS_DISCARDED\n          /* @min:%2eeventsDiscarded */\n          ](events, reason);\n        });\n      };\n      /**\r\n       * [Optional] A function called when the events have been requested to be sent to the sever.\r\n       * @param {number} sendReason - The reason why the event batch is being sent.\r\n       * @param {boolean} isAsync   - A flag which identifies whether the requests are being sent in an async or sync manner.\r\n       */\n\n\n      _self[STR_EVENTS_SEND_REQUEST\n      /* @min:%2eeventsSendRequest */\n      ] = function (sendReason, isAsync) {\n        _runListeners(_self[_DYN_LISTENERS\n        /* @min:%2elisteners */\n        ], STR_EVENTS_SEND_REQUEST, isAsync, function (listener) {\n          listener[STR_EVENTS_SEND_REQUEST\n          /* @min:%2eeventsSendRequest */\n          ](sendReason, isAsync);\n        });\n      };\n\n      _self[STR_PERF_EVENT\n      /* @min:%2eperfEvent */\n      ] = function (perfEvent) {\n        if (perfEvent) {\n          // Send all events or only parent events\n          if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT\n          /* @min:%2eisChildEvt */\n          ]()) {\n            _runListeners(_self[_DYN_LISTENERS\n            /* @min:%2elisteners */\n            ], STR_PERF_EVENT, false, function (listener) {\n              if (perfEvent[_DYN_IS_ASYNC\n              /* @min:%2eisAsync */\n              ]) {\n                setTimeout(function () {\n                  return listener[STR_PERF_EVENT\n                  /* @min:%2eperfEvent */\n                  ](perfEvent);\n                }, 0);\n              } else {\n                listener[STR_PERF_EVENT\n                /* @min:%2eperfEvent */\n                ](perfEvent);\n              }\n            });\n          }\n        }\n      };\n    });\n  } // Removed Stub for NotificationManager.prototype.addNotificationListener.\n  // Removed Stub for NotificationManager.prototype.removeNotificationListener.\n  // Removed Stub for NotificationManager.prototype.eventsSent.\n  // Removed Stub for NotificationManager.prototype.eventsDiscarded.\n  // Removed Stub for NotificationManager.prototype.eventsSendRequest.\n  // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  // this will be removed when ES3 support is dropped.\n\n\n  NotificationManager.__ieDyn = 1;\n  return NotificationManager;\n}();\n\nexport { NotificationManager }; //# sourceMappingURL=NotificationManager.js.map","map":null,"metadata":{},"sourceType":"module"}